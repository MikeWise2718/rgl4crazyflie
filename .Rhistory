rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
?rgl
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
plotPartsInCircle <- function(partList, radius = 80) {   colors <- c("white", "gray", "gray", "green", "yellow", "darkgray", "black", "black")   alpha <- c(    0.4,     1,       1,       1,        1,       1,      1,        1)   shine <- c(    50,     50,      50,      50,       50,      50,     50,       50)   n <- length(partList)   for (i in 1:n) {     print(attr(partList[[i]],"partname"))     rad <- radius     ang <- (i - 1) * 2 * pi / n     cosang <- cos(ang)     sinang <- sin(ang)     off <- c(rad * cosang, rad * sinang, 0)     plotPart(partList[[i]], off, NULL, colors[[i]], alpha[[i]], shine[[i]])   }   addAxes(len = rad/2) } plotPartsInCircle(partList, 50)
plotPart <- function(vertList, trn = c(0,0,0), rot=NULL, color="silver",alpha=1,shiny=shiny) {   lx <- list()   ly <- list()   lz <- list()   xi <- 1   yi <- 2   zi <- 3   for (v in vertList) {     if (length(v) == 4) {       lx <- append(lx, v[[2]][xi] )       lx <- append(lx, v[[3]][xi] )       lx <- append(lx, v[[4]][xi])       ly <- append(ly, v[[2]][yi] )       ly <- append(ly, v[[3]][yi] )       ly <- append(ly, v[[4]][yi])       lz <- append(lz, v[[2]][zi] )       lz <- append(lz, v[[3]][zi] )       lz <- append(lz, v[[4]][zi] )     }   }   vx <- unlist(lx)    vy <- unlist(ly)    vz <- unlist(lz)    if (!is.null(rot)) {     print("rotating")     ux <- vx     uy <- vy     uz <- vz     vx <- ux*rot[1,1] + uy*rot[2,1] + uz*rot[3,1]     vx <- ux*rot[1,2] + uy*rot[2,2] + uz*rot[3,2]     vz <- ux*rot[1,3] + uy*rot[2,3] + uz*rot[3,3]   }   vx <- vx + trn[[xi]]   vy <- vy + trn[[yi]]   vy <- vz + trn[[zi]]   triangles3d( vx,vy,vz, color=color,alpha=alpha,shiny=shiny) } addAxes <- function(len = 1) {   u <- c(0,1)*len   v <- c(0,0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u,v,w,c("","X"),color=c("red"))   lines3d(w,u,v,color=c("green"))   text3d(w,u,v,c("","Y"),color=c("green"))   lines3d(v,w,u,color=c("blue"))   text3d(v,w,u,c("","Z"),color=c("blue")) } # Load everything partList <- sapply(stlfiles, function(x) loadStl(stldir, x)) plotPartsInCircle <- function(partList, radius = 80) {   colors <- c("white", "gray", "gray", "green", "yellow", "darkgray", "black", "black")   alpha <- c(    0.4,     1,       1,       1,        1,       1,      1,        1)   shine <- c(    50,     50,      50,      50,       50,      50,     50,       50)   n <- length(partList)   for (i in 1:n) {     print(attr(partList[[i]],"partname"))     rad <- radius     ang <- (i - 1) * 2 * pi / n     cosang <- cos(ang)     sinang <- sin(ang)     trn <- c(rad * cosang, rad * sinang, 0)     plotPart(partList[[i]], trn, NULL, colors[[i]], alpha[[i]], shine[[i]])   }   addAxes(len = rad/2) } plotPartsInCircle(partList, 50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
cls
rtvs::debug_source("rgl4crazyflie.R")
# Temp and ugly colors <- c("white", "gray", "gray", "green", "yellow", "darkgray", "black", "black") alpha <- c(0.4, 1, 1, 1, 1, 1, 1, 1) shine <- c(50, 50, 50, 50, 50, 50, 50, 50) for (i in 1:8) {   attr(partList[[i]],"color") <- colors[[i]]   attr(partList[[i]],"alpha") <- alpha[[i]]   attr(partList[[i]],"shine") <- shine[[i]] }
plotPartsInCircle <- function(partList, radius = 80) {   n <- length(partList)   for (i in 1:n) {     prt <- partList[[i]]     print(attr(prt,"partname"))     rad <- radius     ang <- (i - 1) * 2 * pi / n     cosang <- cos(ang)     sinang <- sin(ang)     trn <- c(rad * cosang, rad * sinang, 0)     clr <- attr(p,"color")     alf <- attr(p, "alpha")     shn <- attr(p, "shine")     plotPart(prt, trn, NULL, clr,alf,shn)   }   addAxes(len = rad/2) }
plotPartsInCircle(partList, 50)
plotPartsInCircle <- function(partList, radius = 80) {   n <- length(partList)   for (i in 1:n) {     prt <- partList[[i]]     print(attr(prt,"partname"))     rad <- radius     ang <- (i-1)*2*pi/n     cosang <- cos(ang)     sinang <- sin(ang)     trn <- c(rad * cosang, rad * sinang, 0)     clr <- attr(prt,"color")     alf <- attr(prt, "alpha")     shn <- attr(prt, "shine")     plotPart(prt, trn, NULL, clr,alf,shn)   }   addAxes(len = rad/2) } plotPartsInCircle(partList, 50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
v <- as.numeric("1 2")
v
v <- as.numeric(str_split("1 2","\s")[[1]])
v <- as.numeric(str_split("1 2","\\s")[[1]])
v
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
?str_detect
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
?xml_find
?xml_find_first
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
?rgl.translate
?rgl.translate3d
?rgl
??rgl
translate3d
library(rgl)
translate3d
findAnywhere(translate3d)
findAnywhere("translate3d")
findanywhere("translate3d")
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- scale3d(cube3d(), x1, y1, z1)   wire3d(translate3d(mycube, x, y, z)) } printBox(0, 0, 0, 1, 1, 1)
open3d() x <- 0 y <- 0 z <- 0 x1 <- 0 y1 <- 0 z1 <- 0 mycube <- scale3d(cube3d(), x1, y1, z1) wire3d(translate3d(mycube, x, y, z))
open3d() x <- 0 y <- 0 z <- 0 x1 <- 1 y1 <- 1 z1 <- 1 mycube <- scale3d(cube3d(), x1, y1, z1) wire3d(translate3d(mycube, x, y, z))
cube3d
cube3d()
class(cube3d)
cc <- cube3d()
class(cc)
attributes(cc)
class(translate3d(cc))
class(translate3d(cc,1,1,1))
cct <- translate3d(cc,1,1,1)
rtvs::debug_source("rgl4crazyflie.R")
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- scale3d(cube3d(), x1, y1, z1)   wire3d(translate3d(mycube, x, y, z)) } addAxes <- function(len = 1) {   u <- c(0, 1) * len   v <- c(0, 0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u, v, w, c("", "X"), color = c("red"))   lines3d(w, u, v, color = c("green"))   text3d(w, u, v, c("", "Y"), color = c("green"))   lines3d(v, w, u, color = c("blue"))   text3d(v, w, u, c("", "Z"), color = c("blue")) }
set.seed(123) for (i in 1:10) {   x <- runif(1)   y <- runif(1)   z <- runif(1)   sz <- 0.1   printBox(x, y, z, sz,sz,sz ) } addAxes()
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- scale3d(cube3d(), x1, y1, z1)   wire3d(translate3d(mycube, x, y, z)) } addAxes <- function(len = 1) {   # add some p   u <- c(0, 1) * len   v <- c(0, 0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u, v, w, c("", "X"), color = c("red"))   lines3d(w, u, v, color = c("green"))   text3d(w, u, v, c("", "Y"), color = c("green"))   lines3d(v, w, u, color = c("blue"))   text3d(v, w, u, c("", "Z"), color = c("blue")) } set.seed(123) for (i in 1:4) {   x <- runif(1)   y <- runif(1)   z <- runif(1)   sz <- 0.1   printBox(x, y, z, sz,sz,sz ) } axes3d()
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)) # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 4 boxes along a line for (i in 1:4) {   x <- i/4 
  y <- i/4
  z <- i/4   printBox(x, y, z, 0.1,0.1,0.1 ) } axes3d()  # add some axes
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)) # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 4 boxes along a line for (i in 1:4) {   x <- i/4 
  y <- i/4
  z <- i/4   printBox(x, y, z, 0.1,0.1,0.1 ) } axes3d()  # add some axes
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)) # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 4 boxes along a line for (i in 1:4) {   x <- i/4 
  y <- i/4
  z <- i/4   printBox(x, y, z, 0.1,0.1,0.1 ) } axes3d()  # add some axes
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)) # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 4 boxes along a line #for (i in 1:4) {   #x <- i/4 
  #y <- i/4
  #z <- i/4   #printBox(x, y, z, 0.1,0.1,0.1 ) #} axes3d()  # add some axes
open3d()
axes3d()
open3d() #printBox <- function(x, y, z, x1, y1, z1) {   #mycube <- cube3d()                      # create a cube as mesh object      #mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   #mycube <- translate3d(mycube, x, y, z)) # now move it to x,y,z   #wire3d(mycube)                          # now plot it as a wireframe #} # Display 4 boxes along a line #for (i in 1:4) {   #x <- i/4 
  #y <- i/4
  #z <- i/4   #printBox(x, y, z, 0.1,0.1,0.1 ) #} axes3d()  # add some axes
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)) # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 4 boxes along a line #for (i in 1:4) {   #x <- i/4 
  #y <- i/4
  #z <- i/4   #printBox(x, y, z, 0.1,0.1,0.1 ) #} axes3d()  # add some axes
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)) # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe   print ("here I am") } # Display 4 boxes along a line #for (i in 1:4) {   #x <- i/4 
  #y <- i/4
  #z <- i/4   #printBox(x, y, z, 0.1,0.1,0.1 ) #} axes3d()  # add some axes
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe   print ("here I am") } # Display 4 boxes along a line #for (i in 1:4) {   #x <- i/4 
  #y <- i/4
  #z <- i/4   #printBox(x, y, z, 0.1,0.1,0.1 ) #} axes3d()  # add some axes
open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe   print ("here I am") }  Display 4 boxes along a line for (i in 1:4) {   x <- i/4 
  y <- i/4
  z <- i/4   printBox(x, y, z, 0.1,0.1,0.1 ) } axes3d()  # add some axes
library(rgl) open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe   print ("here I am") }  Display 4 boxes along a line for (i in 1:4) {   x <- i/4 
  y <- i/4
  z <- i/4   printBox(x, y, z, 0.1,0.1,0.1 ) } axes3d()  # add some axes
library(rgl) open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe }  Display 4 boxes along a line for (i in 1:4) {   x <- i/4 
  y <- i/4
  z <- i/4   printBox(x, y, z, 0.1,0.1,0.1 ) } axes3d()  # add some axes
library(rgl) open3d() printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 5 boxes along a diagonal line n <- 5 for (i in 1:n) {   x <- i/n 
  y <- i/n
  z <- i/n   sz <- i/(2*n)   printBox(x, y, z, 0.1,0.1,0.1 ) } axes3d()  # add some axes
library(rgl) open3d() # create and plot a box at (x,y,z) of size (x1,y1,z1) printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 5 boxes along a diagonal line n <- 5 for (i in 1:n) {   x <- i/n 
  y <- i/n
  z <- i/n   sz <- i/(2*n)   printBox(x, y, z, 0.1,0.1,0.1 ) } axes3d()  # add some axes
library(rgl) open3d() # create and plot a box at (x,y,z) of size (x1,y1,z1) printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 5 boxes along a diagonal line n <- 5 for (i in 1:n) {   x <- i/n 
  y <- i/n
  z <- i/n   sz <- i/(2*n)   printBox(x, y, z, sz,sz,sz ) } axes3d()  # add some axes
library(rgl) open3d() # create and plot a box at (x,y,z) of size (x1,y1,z1) printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 5 boxes along a diagonal line n <- 5 for (i in 1:n) {   x <- i/n 
  y <- i/n
  z <- i/n   sz <- 1/n   printBox(x, y, z, sz,sz,sz ) } axes3d()  # add some axes
library(rgl) open3d() # create and plot a box at (x,y,z) of size (x1,y1,z1) printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d()                      # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1)   # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z)  # now move it to x,y,z   wire3d(mycube)                          # now plot it as a wireframe } # Display 5 boxes along a diagonal line n <- 5 for (i in 1:n) {   x <- i/n 
  y <- i/n
  z <- i/n   sz <- 1/(2*n)   printBox(x, y, z, sz,sz,sz ) } axes3d()  # add some axes
library(rgl) open3d() # create and plot a box at (x,y,z) of size (x1,y1,z1) printBox <- function(x, y, z, x1, y1, z1) {   mycube <- cube3d() # create a cube as mesh object      mycube <- scale3d(mycube, x1, y1, z1) # now scale that object by x1,y1,z1   mycube <- translate3d(mycube, x, y, z) # now move it to x,y,z   wire3d(mycube) # now plot it to rgl as a wireframe } # Display 5 boxes along a diagonal line n <- 5 for (i in 1:n) {   x <- i / n   y <- i / n   z <- i / n   sz <- 1 / (2 * n)   printBox(x, y, z, sz, sz, sz) } axes3d() # add some axes
source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
306-54
232+54
232+46
306-46
  mList <- list()   idxList <- list()   pntList <- list()   mList[[1]] <- idxList   mList[[2]] <- pntList
v <- c(1.1,2.2,3.3)
addaddVert <- function(mList, v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList[[ np+1 ]] <- v   mList$idxList[[ ni+1 ]] <- ni+1   return(mList) }
addVert(mList,v)
addVert <- function(mList, v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList[[ np+1 ]] <- v   mList$idxList[[ ni+1 ]] <- ni+1   return(mList) }
addVert(mList,v)
mList
sum(T + T:exp(T + pi)) - T
T
ll <- list()
ll$asdf <- list()
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
startime <- Sys.time()
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
?rotate3d
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
traceback()
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
tail(vidx)
length(vpnt)
11700 / 3
shade3d(part)
traceback()
max(vidx)
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
max(vidx)
head(vpnt)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
open3d() addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList[[np + 1]] <- v[1]   mList$pntList[[np + 2]] <- v[2]   mList$pntList[[np + 3]] <- v[3]   mList$idxList[[ni + 1]] <- ni + 1   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx) wire3d(part)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) open3d() addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList[[np + 1]] <- v[1]   mList$pntList[[np + 2]] <- v[2]   mList$pntList[[np + 3]] <- v[3]   mList$idxList[[ni + 1]] <- ni + 1   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx) wire3d(part)
?tmesh3d
addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList[[np + 1]] <- v[1]   mList$pntList[[np + 2]] <- v[2]   mList$pntList[[np + 3]] <- v[3]   mList$idxList[[ni + 1]] <- ni + 1   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx,homongenous=F) wire3d(part)
library(rgl) open3d() addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList[[np + 1]] <- v[1]   mList$pntList[[np + 2]] <- v[2]   mList$pntList[[np + 3]] <- v[3]   mList$idxList[[ni + 1]] <- ni + 1   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx,homogeneous = F) wire3d(part)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) open3d() addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   #  mList$pntList[[ np+1 ]] <- v[1]   #  mList$pntList[[ np+2 ]] <- v[2]   #  mList$pntList[[ np+3 ]] <- v[3]   #  mList$idxList[[ ni+1 ]] <- ni+1   mList$pntList <- c(mList$pntList,v[1],v[2],v[3])   mList$idxList <- c(mList$idxist,ni + 1)   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx,homogeneous = F) wire3d(part)
rtvs::debug_source("D:/local/rgl4crazyflie/onetri.R", encoding = "Windows-1252")
c(list(),1)
c(list(),1,2)
c(mList$pntList,v[1],v[2],v[3])
mList$pntList <- c(mList$pntList,v[1],v[2],v[3])
pntList <- c(mList$pntList,v[1],v[2],v[3])
a <- 2
source("D:/local/rgl4crazyflie/onetri.R", encoding = "Windows-1252")
rtvs::debug_source("D:/local/rgl4crazyflie/onetri.R", encoding = "Windows-1252")
library(rgl) open3d() addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   #  mList$pntList[[ np+1 ]] <- v[1]   #  mList$pntList[[ np+2 ]] <- v[2]   #  mList$pntList[[ np+3 ]] <- v[3]   #  mList$idxList[[ ni+1 ]] <- ni+1   mList$pntList <- c(mList$pntList,v[1],v[2],v[3])   mList$idxList <- c(mList$idxist,ni + 1)   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx,homogeneous = F) wire3d(part)
library(rgl) open3d() addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   #  mList$pntList[[ np+1 ]] <- v[1]   #  mList$pntList[[ np+2 ]] <- v[2]   #  mList$pntList[[ np+3 ]] <- v[3]   #  mList$idxList[[ ni+1 ]] <- ni+1   mList$pntList <- c(mList$pntList,v[1],v[2],v[3])   mList$idxList <- c(mList$idxist,ni + 1)   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx,homogeneous = F) wire3d(part)
library(rgl) open3d() addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   #  mList$pntList[[ np+1 ]] <- v[1]   #  mList$pntList[[ np+2 ]] <- v[2]   #  mList$pntList[[ np+3 ]] <- v[3]   #  mList$idxList[[ ni+1 ]] <- ni+1   mList$pntList <- c(mList$pntList,v[1],v[2],v[3])   mList$idxList <- c(mList$idxist,ni + 1)   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx,homogeneous = F) wire3d(part)
rtvs::debug_source("D:/local/rgl4crazyflie/onetri.R", encoding = "Windows-1252")
rtvs::debug_source("D:/local/rgl4crazyflie/onetri.R", encoding = "Windows-1252")
library(rgl) open3d() addVert <- function(mList,v) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   #  mList$pntList[[ np+1 ]] <- v[1]   #  mList$pntList[[ np+2 ]] <- v[2]   #  mList$pntList[[ np+3 ]] <- v[3]   #  mList$idxList[[ ni+1 ]] <- ni+1   mList$pntList <- c(mList$pntList,v[1],v[2],v[3])   mList$idxList <- c(mList$idxList,ni + 1)   return(mList) } addTri <- function(mList,v1,v2,v3) {   mList <- addVert(mList,v1)   mList <- addVert(mList,v2)   mList <- addVert(mList,v3)   return(mList) } mList <- list() mList$idxList <- list() mList$pntList <- list() v1 <- c(1,0,0) v2 <- c(0,1,0) v3 <- c(0,0,1) mList <- addTri(mList,v1,v2,v3) vidx <- unlist(mList$idxList) vpnt <- unlist(mList$pntList) part <- tmesh3d(vpnt,vidx,homogeneous = F) wire3d(part)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
traceback()
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
model <- ashape3d(rtorus(1000,0.5,2),alpha = 0.25) vert <- model$x[model$vert[,2] == 1,] vert <- cbind(vert,rep(1,nrow(vert))) tria <- model$triang[model$triang[,4] == 1,1:3] tetr <- model$tetra[model$tetra[,6] == 1,1:4] m3dTria <- tmesh3d(vertices = vert,indices = tria) m3dTetr <- qmesh3d(vertices = vert,indices = tetr) m3d <- mergeMeshes(m3dTria,m3dTetr) plot.ashape3d(model) # works fine plot3d(m3d) # Error in x$vb[1, x$it] : subscript out of bounds
install.packages("alphashape3d")
library(rgl) library(alphashape3d) model <- ashape3d(rtorus(1000,0.5,2),alpha = 0.25) vert <- model$x[model$vert[,2] == 1,] vert <- cbind(vert,rep(1,nrow(vert))) tria <- model$triang[model$triang[,4] == 1,1:3] tetr <- model$tetra[model$tetra[,6] == 1,1:4] m3dTria <- tmesh3d(vertices = vert,indices = tria) m3dTetr <- qmesh3d(vertices = vert,indices = tetr) m3d <- mergeMeshes(m3dTria,m3dTetr) plot.ashape3d(model) # works fine plot3d(m3d) # Error in x$vb[1, x$it] : subscript out of bounds
install.packages("Morpho")
library(morpho)
library(Morpho)
library(rgl) library(alphashape3d) library(Morpho) model <- ashape3d(rtorus(1000,0.5,2),alpha = 0.25) vert <- model$x[model$vert[,2] == 1,] vert <- cbind(vert,rep(1,nrow(vert))) tria <- model$triang[model$triang[,4] == 1,1:3] tetr <- model$tetra[model$tetra[,6] == 1,1:4] m3dTria <- tmesh3d(vertices = vert,indices = tria) m3dTetr <- qmesh3d(vertices = vert,indices = tetr) m3d <- mergeMeshes(m3dTria,m3dTetr) plot.ashape3d(model) # works fine plot3d(m3d) # Error in x$vb[1, x$it] : subscript out of bounds
library(alphashape3d) library(Morpho) model <- ashape3d(rtorus(1000,0.5,2),alpha = 0.25) vert <- model$x[model$vert[,2] == 1,] vert <- cbind(vert,rep(1,nrow(vert))) tria <- model$triang[model$triang[,4] == 1,1:3] tetr <- model$tetra[model$tetra[,6] == 1,1:4] m3dTria <- tmesh3d(vertices = vert,indices = tria,homogenous=F) m3dTetr <- qmesh3d(vertices = vert,indices = tetr,homogenous=F) m3d <- mergeMeshes(m3dTria,m3dTetr) plot.ashape3d(model) # works fine plot3d(m3d) # Error in x$vb[1, x$it] : subscript out of bounds
library(alphashape3d) library(Morpho) model <- ashape3d(rtorus(1000,0.5,2),alpha = 0.25) vert <- model$x[model$vert[,2] == 1,] vert <- cbind(vert,rep(1,nrow(vert))) tria <- model$triang[model$triang[,4] == 1,1:3] tetr <- model$tetra[model$tetra[,6] == 1,1:4] m3dTria <- tmesh3d(vertices = vert,indices = tria,homogeneous=F) m3dTetr <- qmesh3d(vertices = vert,indices = tetr,homogeneous=F) m3d <- mergeMeshes(m3dTria,m3dTetr) plot.ashape3d(model) # works fine plot3d(m3d) # Error in x$vb[1, x$it] : subscript out of bounds
model <- ashape3d(rtorus(1000,0.5,2),alpha = 0.25) vert <- model$x[model$vert[,2] == 1,] #vert <- cbind(vert,rep(1,nrow(vert))) tria <- model$triang[model$triang[,4] == 1,1:3] tetr <- model$tetra[model$tetra[,6] == 1,1:4] m3dTria <- tmesh3d(vertices = vert,indices = tria,homogeneous=F) m3dTetr <- qmesh3d(vertices = vert,indices = tetr,homogeneous=F) m3d <- mergeMeshes(m3dTria,m3dTetr) plot.ashape3d(model) # works fine plot3d(m3d) # Error in x$vb[1, x$it] : subscript out of bounds
library(rgl) library(alphashape3d) library(Morpho) model <- ashape3d(rtorus(1000,0.5,2),alpha = 0.25) vert <- model$x[model$vert[,2] == 1,] #vert <- cbind(vert,rep(1,nrow(vert))) tria <- model$triang[model$triang[,4] == 1,1:3] tetr <- model$tetra[model$tetra[,6] == 1,1:4] m3dTria <- tmesh3d(vertices = vert,indices = tria,homogeneous=F) m3dTetr <- qmesh3d(vertices = vert,indices = tetr,homogeneous=F) m3d <- mergeMeshes(m3dTria,m3dTetr) plot.ashape3d(model) # works fine plot3d(m3d) # Error in x$vb[1, x$it] : subscript out of bounds
plot.ashape3d(model) # works fine
library(hash)
install.packages("hash")
v <- c(1.1,2.2,3.3)
h <- hash()
library(hash)
h <- hash()
h[v] <- 1
v1 <- c(1.2,1.3,1.4)
has.key(h,v)
has.key(v,h)
h[v]
h[v] <- 1
v
h[v]
h <- hash(letters,1:26)
h$a
h <- hash()
h[[v]] <- 1
h[v] <- 1
h
as.character(v)
sprintf("%e",v)
sprintf("%f",v)
sprintf("%e",v)
is.null(asdfasdf)
is.null("asdfasdf")
exists(asdfasdf)
exists("h")
exists("h1")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
v
vkey <- sprintf("%e",v)
has.key(vkey,vhashtab)
  vkey <- paste0(sprintf("%e",v))
vkey
  vkey <- paste0(sprintf("%e",v),collapse=",")
vkey
  vkey <- paste0(sprintf("%e",v),collapse=",")
has.key(vkey,vhashtab)
  vhashtab[vkey] <- ni+1
ni <- 0
  vhashtab[vkey] <- ni+1
vhashtab[vkey]
vhashtab[vkey][[2]]
vhashtab[vkey]
vhashtab
vhashtab[[1]] <- 2
vhashtab[1] <- 2
vhashtab[1] 
vhashtab[[1]] 
?get
hashtab.get(1,2)
vhashtab.get(1,2)
h <- hash(letters,1:26)
h[["a"]]
h["a"]
vhashtab[[vkey]]
rtvs::debug_source("rgl4crazyflie.R")
traceback()
rtvs::debug_source("rgl4crazyflie.R")
mList$idxList <- c(mList$idxList,ni + 1)
traceback()
rtvs::debug_source("rgl4crazyflie.R")
mList$idxList <- c(mList$idxList,ni + 1)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
sprintf("tmesh3d - nv:%d np:%d ni:%d maxi:%d mini:%d - vsaved:%d",nv,np,vi,max(vidx),min(vidx),vsv)
sprintf("tmesh3d - nv:%d np:%d ni:%d maxi:%d mini:%d",nv,np,vi,max(vidx),min(vidx))
sprintf("tmesh3d - nv:%d np:%d ni:%d",nv,np,vi)
sprintf("tmesh3d - nv:%d np:%d ",nv,np)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
matrix
rtvs::debug_source("rgl4crazyflie.R")
vpts <- matrix(vpnt,nrow = np / 3,ncol = 3)
vpts1 <- as.numeric(vpts)
bsq <- 0:(np-1)
    bsq <- 3*(0:(np-1))
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
v1 <- vpnt[bsq+1]
sum(is.na(va))
sum(is.na(v1))
length(v1)
    bsq <- 3*(0:(nv-1))
    cx <- mean(vpnt[bsq+1])
cx
length(bsq)
nv
np
length(    bsq <- 1:(np/3)-1)
    bsq <- 1:(np/3)-1
length(bsq)
    cx <- mean(vpnt[bsq+1])
cx
    cy <- mean(vpnt[bsq+2])
cy
    cz <- mean(vpnt[bsq+3])
cz
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
traceback()
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
val
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
clst <- grabComposition(stldir,"Crazyflie_assembly.xml") printComposition(clst)
grabComposition <- function(stldir,xfname) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   compList <- list()   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- str_split(compname,"-")[[1]][[1]]     thisCompPart <- list()     thisCompPart$compname <- compname     thisCompPart$partname <- partname     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       thisCompPart$trn <- rot       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000 * as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       thisCompPart$trn <- trn       compList[[compname]] <- thisCompPart     }   }   return(compList) } printComposition <- function(compList) {   for (cp in compList) {     print(sprintf("%s - %s",cp$compname,cp$partname))   } }
clst <- grabComposition(stldir,"Crazyflie_assembly.xml")
grabComposition <- function(stldir,xfname) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   compList <- list()   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- str_split(compname,"-")[[1]][[1]]     thisCompPart <- list()     thisCompPart$compname <- compname     thisCompPart$partname <- needpart     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       thisCompPart$trn <- rot       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000 * as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       thisCompPart$trn <- trn       compList[[compname]] <- thisCompPart     }   }   return(compList) } printComposition <- function(compList) {   for (cp in compList) {     print(sprintf("%s - %s",cp$compname,cp$partname))   } }
clst <- grabComposition(stldir,"Crazyflie_assembly.xml")
printComposition(clst)
printComposition <- function(compList) {   for (cp in compList) {     print(sprintf("%s - %s",cp$compname,cp$partname))     print(cp$rot)     print(cp$trn)   } }
printComposition(clst)
grabComposition <- function(stldir,xfname) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   compList <- list()   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- str_split(compname,"-")[[1]][[1]]     thisCompPart <- list()     thisCompPart$compname <- compname     thisCompPart$partname <- needpart     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       thisCompPart$rot <- rot       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000 * as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       thisCompPart$trn <- trn       compList[[compname]] <- thisCompPart     }   }   return(compList) }
clst <- grabComposition(stldir,"Crazyflie_assembly.xml")
printComposition(clst)
plotWholeThing <- function(partList,compList) {   for (cp in compList) {     #print(as.character(it))     compname <- cp$compname     needpart <- str_split(compname,"-")[[1]][[1]]     print(sprintf("Comp:%s need:%s",compname,needpart))     if (length(tform) > 0) {       rot <- cp$rot       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- cp$trn       prt <- getElement(partList,needpart)       clr <- attr(prt,"color")       alf <- attr(prt,"alpha")       shn <- attr(prt,"shine")       #plotPart(compname,partname,prt, trn, rot, clr, alf, shn)       plotPartAsMesh(compname,partname,prt,trn,rot,clr,alf,shn)     }   }   addAxes(len = 50)   axes3d() }
plotWholeThing(partList,compList)
compList <- grabComposition(stldir,"Crazyflie_assembly.xml")
plotWholeThing(partList,compList)
plotWholeThing <- function(partList,compList) {   for (cp in compList) {     #print(as.character(it))     compname <- cp$compname     needpart <- str_split(compname,"-")[[1]][[1]]     print(sprintf("Comp:%s need:%s",compname,needpart))     rot <- cp$rot     ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt     trn <- cp$trn     prt <- getElement(partList,needpart)     clr <- attr(prt,"color")     alf <- attr(prt,"alpha")     shn <- attr(prt,"shine")       #plotPart(compname,partname,prt, trn, rot, clr, alf, shn)     plotPartAsMesh(compname,partname,prt,trn,rot,clr,alf,shn)   }   addAxes(len = 50)   axes3d() }
plotWholeThing(partList,compList)
plotWholeThing <- function(partList,compList) {   for (cp in compList) {     compname <- cp$compname     needpart <- str_split(compname,"-")[[1]][[1]]     print(sprintf("Comp:%s need:%s",compname,needpart))     rot <- cp$rot     trn <- cp$trn     prt <- getElement(partList,needpart)     clr <- attr(prt,"color")     alf <- attr(prt,"alpha")     shn <- attr(prt,"shine")       #plotPart(compname,partname,prt, trn, rot, clr, alf, shn)     plotPartAsMesh(compname,partname,prt,trn,rot,clr,alf,shn)   }   addAxes(len = 50)   axes3d() }
plotWholeThing(partList,compList)
grabMaterials <- function(stldir,xfname,compList) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   compList <- list()   itree <- xml_find_first(doc,"//*[local-name()='Parts']")   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it,"name")     cp <- compList[[compname]]     if (!is.null(cp)) {       print(sprintf("Part:%s",compname))       amb <- xml_find_first(it,".//*[local-name()='Ambient']")       a1 <- xml_attr(amb,"r")       a2 <- xml_attr(amb,"g")       a3 <- xml_attr(amb,"b")       a4 <- xml_attr(amb,"a")       cp$ambient <- c(a1,a2,a3,a4)       compList[[compname]] <- cp     }   }   return(compList) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
grabMaterials <- function(stldir,xfname,compList) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   compList <- list()   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it,"name")     cp <- compList[[compname]]     if (!is.null(cp)) {       print(sprintf("Part:%s",compname))       amb <- xml_find_first(it,".//*[local-name()='Ambient']")       a1 <- xml_attr(amb,"r")       a2 <- xml_attr(amb,"g")       a3 <- xml_attr(amb,"b")       a4 <- xml_attr(amb,"a")       cp$ambient <- c(a1,a2,a3,a4)       print(cp$ambient)       compList[[compname]] <- cp     }   }   return(compList) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
rtvs::debug_source("rgl4crazyflie.R")
grabMaterials <- function(stldir,xfname,compList) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it,"name")     cp <- compList[[compname]]     if (!is.null(cp)) {       print(sprintf("Part:%s",compname))       amb <- xml_find_first(it,".//*[local-name()='Ambient']")       a1 <- xml_attr(amb,"r")       a2 <- xml_attr(amb,"g")       a3 <- xml_attr(amb,"b")       a4 <- xml_attr(amb,"a")       cp$ambient <- c(a1,a2,a3,a4)       print(cp$ambient)       compList[[compname]] <- cp     }   }   return(compList) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
grabMaterials <- function(stldir,xfname,compList) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it,"name")     cp <- compList[[compname]]     if (!is.null(cp)) {       print(sprintf("Part:%s",compname))       amb <- xml_find_first(it,".//*[local-name()='Ambient']")       a1 <- xml_attr(amb,"r")       a2 <- xml_attr(amb,"g")       a3 <- xml_attr(amb,"b")       a4 <- xml_attr(amb,"a")       cp$ambient <- c(a1,a2,a3,a4)       print(cp$ambient)       compList[[compname]] <- cp     }   }   return(compList) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
grabMaterials <- function(stldir,xfname,compList) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it,"name")     cp <- getelement(compList,compname)     if (!is.null(cp)) {       print(sprintf("Part:%s",compname))       amb <- xml_find_first(it,".//*[local-name()='Ambient']")       a1 <- xml_attr(amb,"r")       a2 <- xml_attr(amb,"g")       a3 <- xml_attr(amb,"b")       a4 <- xml_attr(amb,"a")       cp$ambient <- c(a1,a2,a3,a4)       print(cp$ambient)       compList[[compname]] <- cp     }   }   return(compList) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
grabMaterials <- function(stldir,xfname,compList) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it,"name")     cp <- getElement(compList,compname)     if (!is.null(cp)) {       print(sprintf("Part:%s",compname))       amb <- xml_find_first(it,".//*[local-name()='Ambient']")       a1 <- xml_attr(amb,"r")       a2 <- xml_attr(amb,"g")       a3 <- xml_attr(amb,"b")       a4 <- xml_attr(amb,"a")       cp$ambient <- c(a1,a2,a3,a4)       print(cp$ambient)       compList[[compname]] <- cp     }   }   return(compList) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
getElement <- function(partlist, need) {   print(sprintf("getElement:%s",need))   for (p in partlist) {     pelid <- attr(p,"partname")     print(sprintf("   detecting:%s", pelid))     if (str_detect(pelid,need)) {       print(sprintf("returning:%s", pelid))       return(p)     }   }   print(sprintf("returning NULL"))   return(NULL) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
rtvs::debug_source("rgl4crazyflie.R")
getCompElement <- function(compList,need) {   print(sprintf("getElement:%s",need))   for (p in compList) {     pelid <- attr(p,"compname")     print(sprintf("   detecting:%s",pelid))     if (str_detect(pelid,need)) {       print(sprintf("returning:%s",pelid))       return(p)     }   }   print(sprintf("returning NULL"))   return(NULL) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
p$compname
getCompElement <- function(compList,need) {   print(sprintf("getElement:%s",need))   for (p in compList) {     pelid <- p$compname     print(sprintf("   detecting:%s",pelid))     if (str_detect(pelid,need)) {       print(sprintf("returning:%s",pelid))       return(p)     }   }   print(sprintf("returning NULL"))   return(NULL) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
getCompElement <- function(compList,need) {   #print(sprintf("getElement:%s",need))   for (p in compList) {     pelid <- p$compname     #print(sprintf("   detecting:%s",pelid))     if (str_detect(pelid,need)) {       #print(sprintf("returning:%s",pelid))       return(p)     }   }   #print(sprintf("returning NULL"))   return(NULL) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
grabMaterials <- function(stldir,xfname,compList) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it,"name")     cp <- getCompElement(compList,compname)     if (!is.null(cp)) {       print(sprintf("Part:%s",compname))       nod <- xml_find_first(it,".//*[local-name()='Ambient']")       cp$ambient <- c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a"))       nod <- xml_find_first(it,".//*[local-name()='Diffuse']")       cp$diffuse <- c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a"))       nod <- xml_find_first(it,".//*[local-name()='Specular']")       cp$specular <- c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a"))       nod <- xml_find_first(it,".//*[local-name()='Emissive']")       cp$emissive <- c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a"))       print(sprintf("   amb - %.3f %.3f %.3f %.3f",cp$ambient))       print(sprintf("   dif - %.3f %.3f %.3f %.3f",cp$diffuse))       print(sprintf("   spc - %.3f %.3f %.3f %.3f",cp$specular))       print(sprintf("   emi - %.3f %.3f %.3f %.3f",cp$emissive))       compList[[compname]] <- cp     }   }   return(compList) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
grabMaterials <- function(stldir,xfname,compList) {   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it,"name")     cp <- getCompElement(compList,compname)     if (!is.null(cp)) {       print(sprintf("Part:%s",compname))       nod <- xml_find_first(it,".//*[local-name()='Ambient']")       cp$ambient <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Diffuse']")       cp$diffuse <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Specular']")       cp$specular <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Emissive']")       cp$emissive <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       print(sprintf("   amb - %.3f %.3f %.3f %.3f",cp$ambient))       print(sprintf("   dif - %.3f %.3f %.3f %.3f",cp$diffuse))       print(sprintf("   spc - %.3f %.3f %.3f %.3f",cp$specular))       print(sprintf("   emi - %.3f %.3f %.3f %.3f",cp$emissive))       compList[[compname]] <- cp     }   }   return(compList) }
compList <- grabMaterials(stldir,"Crazyflie_assembly.xml",compList)
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
class(cp$ambient)
cp$ambient
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
traceback()
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
partlist[[1]]$ambient
partList[[1]]$ambient
partList[[1]]
attr(partList[[1]],color)
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
prt$ambient
prt[["ambient"]]
prt[[1]]
ppartname <- partname
partList[[ppartname]]$ambient
length(partList)
partList[[1]]$ambient
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
ppartname <- partname
partname
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
col2rgb(c(1,1,1))
?col2rgb
col2rgb(255*c(1,1,1))
iclr <- round(255 * prta$ambient[1:3])
sprintf("#%2.2x2.2x2.2x",iclr)
rgb2col(c(1,1,1))
sprintf("#%2.2d2.2d2.2d",iclr)
sprintf("#%2.2d%2.2d%2.2d",iclr)
sprintf("#%2.2d%2.2d%2.2d",iclr[[1]],iclr[[2]],iclr[[3]])
sprintf("#%2.2x%2.2d%2.2d",iclr[[1]],iclr[[2]],iclr[[3]])
rtvs::debug_source("rgl4crazyflie.R")
open3d() library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie",partAttList,partVertList,compList) {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname,rownames=F)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- write.csv(fname)   rv <- list   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } rv <- readMesh("crazyflie",partAttList,partVertList,compList)
  i <- 1   id <- cidf$id[[i]]   ptdf <- r$ptdf[r$ptdf$id == id,]
r <- readMesh("crazyflie",partAttList,partVertList,compList)
readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname,rownames=F)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie")
readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie")
readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie")
  i <- 1   id <- r$cidf$id[[i]]   ptdf <- r$ptdf[r$ptdf$id == id,]
id
r$  i <- 1   id <- r$cdf$id[[i]]   ptdf <- r$ptdf[r$ptdf$id == id,]
cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf #for (i in 1:nrow(r$cdf)) { i <- 1 id <- cdf$id[[i]] ptdf <- ptdf[ptdf$id == id,] ptdf$id <- NULL m <- as.matrix(ptdf)
nm <- as.numeric(m)
i <- 1 id <- cdf$id[[i]] ptdf <- ptdf[ptdf$id == id,] ptdf$id <- NULL mpt <- as.matrix(ptdf) vidf <- vidf[vidf$id == id,] vidf$id <- NULL mvi <- as.matrix(vidf)
open3d()
tmesh3d(mpt,mvi)
part <- tmesh3d(mpt,mvi) shade3d(part)
?tmesh3
?tmesh3d
head(mvi)
mvi[1,1]
mvi[2,1]
max(mvi)
min(mvi)
dim(mpt)
head(mpt)
i <- 1 id <- cdf$id[[i]] ptdf <- ptdf[ptdf$id == id,] ptdf$id <- NULL mpt <- as.matrix(ptdf)
ptdf <- r$ptdf
cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] ptdf$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vidf$id <- NULL mvi <- as.matrix(v1idf) part <- tmesh3d(mpt,mvi) shade3d(part)
mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part)
dim(mvi)
head(mvi)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] ptdf$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] ptdf$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] ptdf$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] ptdf$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part)
head(mpt)
vi1df <- vidf[vidf$id == id,]
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] pt1df$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] pt1df$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] pt1df$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf #for (i in 1:nrow(r$cdf)) { i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] pt1df$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,mvi) shade3d(part) #}
head(vidf)
head(mvi)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] pt1df$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- as.matrix(vi1df) part <- tmesh3d(mpt,t(mvi)) shade3d(part)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] pt1df$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- t(as.matrix(vi1df)) part <- tmesh3d(mpt,mvi) shade3d(part)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] pt1df$id <- NULL mpt <- as.matrix(pt1df) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- t(as.matrix(vi1df)) part <- tmesh3d(mpt,mvi) shade3d(part)
i <- 1 id <- cdf$id[[i]] pt1df <- ptdf[ptdf$id == id,] pt1df$id <- NULL mpt <- t(as.matrix(pt1df)) vi1df <- vidf[vidf$id == id,] vi1df$id <- NULL mvi <- t(as.matrix(vi1df)) part <- tmesh3d(mpt,mvi) shade3d(part)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf for (i in 1:nrow(r$cdf)) {   id <- cdf$id[[i]]   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   part <- tmesh3d(mpt,mvi)   shade3d(part) }
for (i in 1:nrow(r$cdf)) {   id <- cdf$id[[i]]   print(cdf$comp[i])   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   part <- tmesh3d(mpt,mvi)   shade3d(part) }
for (i in 1:nrow(r$cdf)) {   id <- cdf$id[[i]]   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   part <- tmesh3d(mpt,mvi)   shade3d(part) }
for (i in 1:nrow(r$cdf)) {   id <- cdf$id[[i]]   cname <- cdf$comp[i]   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   part <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(part) }
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf for (i in 1:nrow(r$cdf)) {   id <- cdf$id[[i]]   cname <- cdf$comp[i]   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   part <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(part) }
i <- 1
  cname <- cdf$comp[i]
  pt1df <- ptdf[ptdf$id == id,]
cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ptdf$id <- 1 for (i in 1:nrow(r$cdf)) {   id <- cdf$id[[i]]   cname <- cdf$comp[i]   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   part <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(part) }
ptdf$id <- 1 vidf$id <- 1 for (i in 1:nrow(r$cdf)) {   id <- cdf$id[[i]]   cname <- cdf$comp[i]   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   part <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(part) }
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf for (i in 1:nrow(r$cdf)) {   id <- cdf$id[[i]]   cname <- cdf$comp[i]   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   part <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(part) }
x <- c(11,12,13)
which(x==11)
which(x==12)
y <- c(21,22,13)
matrix(c(x,y),2,3)
matrix(c(x,y),3,2)
mamb <- matrix(p$amb.r,p$amb.g,p$amb.b)
mamb <- matrix(pdf$amb.r,pdf$amb.g,pdf$amb.b)
dim(mamb)
mamb <- matrix(pdf$amb.r,pdf$amb.g,pdf$amb.b,3)
dim(mamb)
mamb <- matrix(pdf$amb.r,pdf$amb.g,pdf$amb.b,3,nrow(pdf))
mamb <- matrix(c(pdf$amb.r,pdf$amb.g,pdf$amb.b),3,nrow(pdf))
dim(mamb)
mamb[1,]
mamb <- matrix(c(pdf$amb.r,pdf$amb.g,pdf$amb.b),nrow(pdf),3)
mamb[1,]
mamb[2,]
mamb <- t(matrix(c(pdf$amb.r,pdf$amb.g,pdf$amb.b),3,nrow(pdf)))
mamb[1,]
mamb[2,]
rvek <- pdf$amb.r
bvek <- pdf$amb.b
gvek <- pdf$amb.g
m <- t(matrix(c(rvek,gvek,bvek),3,nrow(pdf))))
m <- t(matrix(c(rvek,gvek,bvek),3,nrow(pdf)))
l <- as.list(m)
colvekToHashString <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) }
rgb <- sapply(l,colvekToHashString)
head(l)
m
l
l <- as.list(t(m))
l
l[[1]]
l[1]
dim(m,2)
dim(m)
dim(m)[2]
1:dim(m)[2]
1:dim(m)[1]
sapply(1:dim(m)[1],function (x)m[x,])
lapply(1:dim(m)[1],function (x)m[x,])
  rgb <- sapply(l,colvekToHashString)
l[[2]]
l[[1]]
l <- lapply(1:dim(m)[1],function (x)m[x,])
l[[1]]
  rgb <- sapply(l,colvekToHashString)
rgb
pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)
colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- t(matrix(c(rvek,gvek,bvek),3,nrow(pdf)))# matrix with row as r,g,b   lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) }
pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)
pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- t(matrix(c(rvek,gvek,bvek),3,nrow(pdf)))# matrix with row as r,g,b   lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) for (compidx in 1:ncomp) {   id <- cdf$id[[compidx]]   cname <- cdf$comp[compidx]   pname <- cdf$part[compidx]   pidx <- which(pdf$partname == pname)   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
rtvs::debug_source("D:/local/rgl4crazyflie/readcf.R", encoding = "Windows-1252")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- t(matrix(c(rvek,gvek,bvek),3,nrow(pdf)))# matrix with row as r,g,b   lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) for (compidx in 1:ncomp) {   id <- cdf$id[[compidx]]   cname <- cdf$comp[compidx]   pname <- cdf$part[compidx]   pidx <- which(pdf$partname == pname)   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
pdf
pdf
names(pdf)
pdf[c(1,2,3,4,5,20),]
pdf[,c(1,2,3,4,5,20)]
m <- t(matrix(c(rvek,gvek,bvek),3,nrow(pdf)))
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- t(matrix(c(rvek,gvek,bvek),3,nrow(pdf)))# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) for (compidx in 1:ncomp) {   id <- cdf$id[[compidx]]   cname <- cdf$comp[compidx]   pname <- cdf$part[compidx]   pidx <- which(pdf$partname == pname)   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
l <- lapply(1:dim(m)[1],function(x) m[x,])
l
pdf[,c(1,2,3,4,5,20)]
m[8,]
m[7,]
m[6,]
rvek
gvek
bvek
matrix(c(rvek,gvek,bvek),3,nrow(pdf))
matrix(c(rvek,gvek,bvek),nrow(pdf),3)
l <- lapply(1:dim(m)[1],function(x) m[x,])
l
m[7,]
m
 m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)
l <- lapply(1:dim(m)[1],function(x) m[x,])
l
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) for (compidx in 1:ncomp) {   id <- cdf$id[[compidx]]   cname <- cdf$comp[compidx]   pname <- cdf$part[compidx]   pidx <- which(pdf$partname == pname)   print(as.character(cdf$comp[i]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) for (cidx in 1:ncomp) {   id <- cdf$id[[compidx]]   cname <- cdf$compname[compidx]   pname <- cdf$partname[compidx]   pidx <- which(pdf$partname == pname)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
for (cidx in 1:ncomp) {   cname <- cdf$compname[compidx]   pname <- cdf$partname[compidx]   pidx <- which(pdf$partname == pname)   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
for (cidx in 1:ncomp) {   cname <- cdf$compname[compidx]   pname <- cdf$partname[compidx]   pidx <- which(pdf$partname == pname)   print(pname)   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
pdf$partname
which(pdf$partname=="pcb")
for (cidx in 1:ncomp) {   cname <- cdf$compname[compidx]   pname <- cdf$partname[compidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
for (cidx in 1:ncomp) {   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
for (cidx in 1:ncomp) {   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
for (cidx in 1:ncomp) {   id <- cdf$id   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
for (cidx in 1:ncomp) {   id <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) for (cidx in 1:ncomp) {   id <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
for (cidx in 1:ncomp) {   id <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
as.matrix(c(11,12,13,21,22,23,31,32,33),3,3)
matrix(c(11,12,13,21,22,23,31,32,33),3,3)
t(matrix(c(11,12,13,21,22,23,31,32,33),3,3))
cdf$rot <- t(matrix(cdf$rot11,cdf$rot12,cdf$13,                     cdf$rot21,cdf$rot22,cdf$23,                     cdf$rot31,cdf$rot32,cdf$33))
cdf$rot <- t(matrix(c(cdf$rot11,cdf$rot12,cdf$13,                       cdf$rot21,cdf$rot22,cdf$23,                       cdf$rot31,cdf$rot32,cdf$33),3,3) )
cdf$rot <- matrix(c(cdf$rot11,cdf$rot12,cdf$13,                       cdf$rot21,cdf$rot22,cdf$23,                       cdf$rot31,cdf$rot32,cdf$33),3,3)
cdf$l <- as.list(1:8)
cdf$l <- as.list(1:17)
cdf$l
cdf[[17]]
cdf$l[[17]]
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) #cdf$rot <- matrix(c(cdf$rot11,cdf$rot12,cdf$13,                       #cdf$rot21,cdf$rot22,cdf$23,                       #cdf$rot31,cdf$rot32,cdf$33),3,3) #cdf$trn <-  for (cidx in 1:ncomp) {   id <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   mesh <   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot11[cidx],cdf$rot12[cidx],cdf$rot13[cidx],                   cdf$rot21[cidx],cdf$rot22[cidx],cdf$rot23[cidx],                   cdf$rot31[cidx],cdf$rot32[cidx],cdf$rot33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,01),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) }
getTrn(cdf,1)
getTrn(cdf,4)
getRot(cdf,4)
names(cdf)
getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,01),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) }
getRot(cdf,4)
getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) }
getRot(cdf,4)
for (cidx in 1:ncomp) {   id <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   print(as.character(pname))   print(pidx)   print(as.character(cdf$compname[cidx]))   pt1df <- ptdf[ptdf$id == id,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   vi1df <- vidf[vidf$id == id,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx]) }
for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) }
for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) }
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))note   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) }
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) }
addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) }
addAxes(10)
addAxes(100)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
  minx <- miny <- minz <-  +9e99
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
?rotate3d
?scaleMatrix
scaleMatrix(1,2,3)
rotate3d(matrix=matrix(1,3,3))
rotate3d(matrix=scaleMatrix(1,2,3))
?identityMatrix
identityMatrix()
rtvs::debug_source("rgl4crazyflie.R")
traceback()
matrix(c(1,0,0,0,1,0,0,0,1),3,3)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
rtvs::debug_source("D:/local/rgl4crazyflie/readcf.R", encoding = "Windows-1252")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   #mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   #mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   mesh <- rotate3d(mesh,matrix = getRot(cdf,cidx))   trn <- getTrn(cdf,cidx)   #mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   print(rot)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   #mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
matrix(c(1,0,0,0,1,0,0,0,1),3,3)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   print(rot)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   print(rot)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
tracebacl)_
tracebacl()
traceback()
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   print(rot)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
    yc <- vb[bsq + 2]
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   print(rot)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   print(rot)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
traceback()
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1) {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u,v,w,color = c("red"))   text3d(u,v,w,c("","X"),color = c("red"))   lines3d(w,u,v,color = c("green"))   text3d(w,u,v,c("","Y"),color = c("green"))   lines3d(v,w,u,color = c("blue"))   text3d(v,w,u,c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   print(rot)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[[1]],trn[[2]],trn[[3]])   # render it   shade3d(mesh,color = pdf$amb[pidx],alpha=pdf$amb.a[pidx])   print(sprintf("%s  pts:%d vidx:%d",cname,length(mpt),length(mvi))) } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
m <- matrix(1.123,2,2)
m
round(m,1)
m <- matrix(1.000001,2,2)
round(m,1)
round(m,2)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
m <- matrix(1e-7,3,3)
m
round(m,2)
round(m,3)
m[1,1] <- sqrt(2)
m[3,1] <- sqrt(2)
m
round(m,1)
round(m,2)
m2 <- round(m,2)
m[2,1]
m[2,2]
m2[2,2]
m2[2,2]
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])   addAxes(10,t=trn,r=rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])   addAxes(10,t=trn,r=rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   #mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])   addAxes(10,t=trn,r=rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   #mesh <- rotate3d(mesh,matrix=rot)   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])   addAxes(10,t=trn,r=rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   if (fcid == 1600) {     mesh <- rotate3d(mesh,matrix=rot)   }   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])   addAxes(10,t=trn,r=rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   if (fcid == 1600) {     mesh <- rotate3d(mesh,matrix=rot)   }   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   if (fcid == 1600 | fcid == 1500) {     shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   if (fcid == 1600) {     omesh <- mesh     mesh <- rotate3d(mesh,matrix=rot)   }   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   if (fcid == 1600 ) {     shade3d(omesh,color = "red",alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   }   if (fcid == 1600 | fcid == 1500) {     shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   if (fcid == 1600) {     omesh <- mesh     omesh <- translate3d(omesh,trn[1],trn[2],trn[3])     mesh <- rotate3d(mesh,matrix=rot)   }   trn <- getTrn(cdf,cidx)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   if (fcid == 1600 ) {     shade3d(omesh,color = "red",alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   }   if (fcid == 1600 | fcid == 1500) {     shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   if (fcid == 1600) {     omesh <- mesh     omesh <- translate3d(omesh,trn[1],trn[2],trn[3])     mesh <- rotate3d(mesh,matrix=rot)   }   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   if (fcid == 1600 ) {     shade3d(omesh,color = "red",alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   }   if (fcid == 1600 | fcid == 1500) {     shade3d(mesh,color = pdf$amb[pidx],alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   if (fcid == 1600) {     omesh <- mesh     omesh <- translate3d(omesh,trn[1],trn[2],trn[3])     mesh <- rotate3d(mesh,matrix=rot)   }   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   if (fcid == 1600) {     clr <- "red"     if (cidx==1) clr <- "blue"     shade3d(omesh,color = clr,alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   }   if (fcid == 1600 | fcid == 1500) {     clr <- pdf$amb[pidx]     if (cidx == 1) clr <- "purple"     shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   if (fcid == 1600) {     omesh <- mesh     omesh <- translate3d(omesh,trn[1],trn[2],trn[3])     mesh <- rotate3d(mesh,matrix=rot)   }   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   if (fcid == 1600) {     clr <- "red"     if (cidx==1) clr <- "orange"     shade3d(omesh,color = clr,alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   }   if (fcid == 1600 | fcid == 1500) {     clr <- pdf$amb[pidx]     clr <- "blue"     if (cidx == 1) clr <- "purple"     shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   if (fcid == 1600) {     omesh <- mesh     omesh <- translate3d(omesh,trn[1],trn[2],trn[3])     mesh <- rotate3d(mesh,matrix=rot)   }   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("D:/local/rgl4crazyflie/readcf.R", encoding = "Windows-1252")
names(mesh)
max(mesh$it)
min(mesh$it)
lenvth(mesh$vb)
length(mesh$vb)
2560 / 3
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
head(ptdf)
head(vidf)
table(vidf$partid)
table(vidf$ptid)
table(vidf$ptdf)
table(ptdf$id)
table(vidf$id)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%d",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   #shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%d",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   #shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
traceback()
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   #shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   #shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == cid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == cid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   #mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to plot CAD model of CrazyFlie mini-drone # #  It performs the following septs #   1. read in STL files from local copy of github repository Crazyflie-CAD #   2. create optimized triangle meshes out of it (optimized in reducing the number of points) #   3. orienting the data so it has the right x,y,z orientation #   4. ploting in in rgl #   5. writing out the data in a small set of csv files #   appendListAsSubEl <- function(vlist,v) {   # Append a list to a list as a sub-element    # i.e. do not merge the lists (thus losing structure)   # and retain the top list's attributes    if (!is.null(v)) {     vlist[[length(vlist) + 1]] <- v     # Note, if we use the faster method below, we loose the attributes of vlist!     # Bad, bad, bad...     # vlist <- c(vlist,v)   }   return(vlist) } extractVert <- function(line) {   rv <- c(0,0,0)   sar <- str_split(line,"[\\s]")[[1]] # only one element in line   n <- length(sar)   if (n >= 3) {     rv <- c(as.numeric(sar[[n-2]]),as.numeric(sar[[n-1]]),as.numeric(sar[[n]]))   }   return(rv) } readVertsFromStl <- function(stldir, stlfname,vertPartList) {   starttime <- Sys.time()   if (!is.null(stldir) & stldir!="") {     stlfname <- sprintf("%s/%s", stldir, stlfname)   }   lines <- readLines(stlfname, warn = F)   nlines0 <- length(lines)   if (nlines0 < 6) {     print(sprintf("File too short:%d", length(nlines0)))     return(NULL)   }   print(sprintf("Read %d lines from %s",nlines0,stlfname))   vertPtList <- list()   # extract the first line which is the name of the part   partname <- lines[[1]]   partname <- gsub("solid ","",partname)   partname <- gsub("_Default_sldprt","",partname)   lines <- lines[2:length(lines)]   # trim out stuff we do not need   lines <- lines[!str_detect(lines,"outer loop")]   lines <- lines[!str_detect(lines,"endloop")]   lines <- lines[!str_detect(lines,"endfacet")]   lines <- lines[!str_detect(lines, "endsolid")]   print(sprintf("Stripped out %d irrelevant lines", nlines0-length(lines)))   # now loop over what is left and accumulate the facet vector   facetvek <- list()   for (line in lines) {     if (str_detect(line, "facet")) {       if (length(facetvek) == 4) {         vertPtList <- appendListAsSubEl(vertPtList,facetvek)       }       facetvek <- list()       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else if (str_detect(line, "vertex")) {       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else {       print(sprintf("opps unknown linetype:%s",line))     }   }   vertPtList <- appendListAsSubEl(vertPtList,facetvek) # add the remaining one tp vertPtList   vertTopList <- list()   vertTopList$vertPtList <- vertPtList   vertTopList$partname <- partname   vertPartList[[partname]] <- vertTopList   elap <- as.numeric((Sys.time() - starttime)[1], units = "secs")   print(sprintf("Extracted %d vertices in %.1f secs for part '%s'", length(vertPtList),elap,partname))   return(vertPartList) } # hash bookkeeping vhashtab <- hash() nvsaved <- 0 nvtot <- 0 addVertHashed <- function(mList,v,n = NULL) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   vkey <- paste0(sprintf("%e",v),collapse=",")   if (has.key(vkey,vhashtab)) {     vval <- vhashtab[[vkey]]     #print(sprintf("np:%d ni:%d vkey:%s nval:%d",np,ni,vkey,nval))     mList$idxList <- c(mList$idxList,vval$vnum)     if (!is.null(n)) {       vval$norm <- vval$norm + n     }     nvsaved <<- nvsaved+1   } else {     vnum <- (np + 3) / 3     vval <- list()     vval$vnum <- vnum     if (!is.null(n)) vval$norm <- n     vhashtab[vkey] <- vval     mList$pntList <- c(mList$pntList,v[1],v[2],v[3])     mList$idxList <- c(mList$idxList,vnum)     nvtot <<- nvtot+1   }   return(mList) } addVert <- function(mList,v,n = NULL) {   # no hashing   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList <- c(mList$pntList, v[1],v[2],v[3])   mList$idxList <- c(mList$idxList, ni+1)   nvtot <<- nvtot+1   return(mList) } addTri <- function(mList,v1,v2,v3,norm,hashemup=T) {   if (hashemup) {     mList <- addVertHashed(mList,v1,norm)     mList <- addVertHashed(mList,v2,norm)     mList <- addVertHashed(mList,v3,norm)   } else {     mList <- addVert(mList,v1,norm)     mList <- addVert(mList,v2,norm)     mList <- addVert(mList,v3,norm)   }   return(mList) } normalize <- function(n) {   vlen <- sqrt(n[[1]]^2 + n[[2]]^2 + n[[3]]^2)   if (vlen>0) {     n <- n/vlen   }   return(n) } plotPartAsMesh <- function(compname,partname,vertTopList,comp,trn = c(0,0,0),rot = NULL,                            amb = "silver",dif=NULL,spc=NULL,ems=NULL,alf = 1,shiny = 50,donorms = F,hashemup = T) {   vhashtab <<- hash()   vertPtList <- vertTopList$vertPtList   mList <- list()   mList$idxList <- list()   mList$pntList <- list()   mList$nrmList <- list()   normval <- NULL   for (v in vertPtList) {     if (length(v) == 4) {       if (donorms) normval <- v[[1]]       mList <- addTri(mList,v[[2]],v[[3]],v[[4]],normval,hashemup=hashemup)      }   }   vidx <- unlist(mList$idxList)   vpnt <- unlist(mList$pntList)   nv <- length(vertPtList)   ni <- length(vidx)   np <- length(vpnt)   # Not sure I can make donorms work right   # giving up for now - 2016.12.1   #   if (donorms) {     nn <- np / 3     for (i in 1:nn) {       bidx <- (i-1)*3       v1 <- vpnt[[bidx+1]]       v2 <- vpnt[[bidx+2]]       v3 <- vpnt[[bidx+3]]       v <- c(v1,v2,v3)       vkey <- paste0(sprintf("%e",v),collapse = ",")       vval <- vhashtab[[vkey]]       mList$nrmList <- c(mList$nrmList,normalize(vval$norm))     }     vnrm <- unlist(mList$nrmList)   }   nvsv <- 3*nv - np   print(sprintf("   tmesh3d - nv:%d np:%d ni:%d maxi:%d mini:%d - vsaved:%d",nv,np,ni,max(vidx),min(vidx),nvsv))   if (donorms) {     part <- tmesh3d(vpnt,vidx,homogeneous=F, normals=vnrm)   } else {     part <- tmesh3d(vpnt,vidx,homogeneous=F)   }   part <- translate3d(rotate3d(part,matrix = rot),trn[[1]],trn[[2]],trn[[3]])   # Center and orient the drone - determined these from the data   # Drone was upside down and facing the wrong way   # making the center to be the center of the pcb board   #   pcbcen <- -0.5*c(54.09200, 71.18820, 75.60720)   part <- translate3d(part,pcbcen[[1]],pcbcen[[2]],pcbcen[[3]])   part <- rotate3d(part,pi,0,1,0 ) # rotate 180 around the y-axis   calccog <- T   if (calccog) {     vb <- part$vb     nvb <- length(vb)     bsq <- (1:(nvb/4) - 1)*4     xc <- vb[bsq + 1]     yc <- vb[bsq + 2]     zc <- vb[bsq + 3]     wc <- vb[bsq + 4]     cx <- mean(min(xc) + max(xc))     cy <- mean(min(yc) + max(yc))     cz <- mean(min(zc) + max(zc))     cw <- mean(min(wc) + max(wc))     tx <- max(xc) - min(xc)     ty <- max(yc) - min(yc)     tz <- max(zc) - min(zc)     tw <- max(wc) - min(wc)     print(sprintf("   cog:%.5f %.5f %.5f %.5f thickness: %.5f %.5f %.5f %.5f",cx,cy,cz,cw,tx,ty,tz,tw))   }   #rgl.material(color=amb,alpha=alf,specular=spc,shininess=shiny)   #shade3d(part)   shade3d(part,color = amb,specular=spc,emissive=ems,alpha = alf,shiny = shiny)   comp$out_vp <- part$vb   comp$out_vi <- part$it   stats <- findBBox(comp$out_vp,compname)   comp$out_vp <- translatePointsFromMatrix(comp$out_vp, -stats$cenv )   comp$out_sca <- c(1,1,1)   # I don't know why this transformation of rot is necessary, but it is..   # m1 swaps Y&Z and then inverts all the axes   #   m1 <- matrix(c(-1,0,0,0,0,-1,0,-1,0),3,3)   comp$out_rot <- m1 %*% rot   comp$out_trn <- stats$cenv   stats <- findBBox(comp$out_vp,compname)   #comp$out_trn <- c(0,0,0)   return(comp) } addAxes <- function(len = 1) {   u <- c(0,1)*len   v <- c(0,0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u,v,w,c("","X"),color=c("red"))   lines3d(w,u,v,color=c("green"))   text3d(w,u,v,c("","Y"),color=c("green"))   lines3d(v,w,u,color=c("blue"))   text3d(v,w,u,c("","Z"),color=c("blue")) } colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } plotWholeThing <- function(partAttList,partVertList,compList) {   for (cp in compList) {     compname <- cp$compname     partname <- gsub("\\-\\d$","",compname)     print(sprintf("Comp:%s part:%s",compname,partname))     rot <- cp$rot     trn <- cp$trn     prta <- partAttList[[partname]]     amb <- colVekToStringColor(prta$ambient)     dif <- colVekToStringColor(prta$diffuse)     spc <- colVekToStringColor(prta$specular)     ems <- colVekToStringColor(prta$emissive)     alf <- prta$ambient[4]     shn <- prta$shinyness     #print(prta$ambient)     vtl <- partVertList[[partname]]     newcp <- plotPartAsMesh(compname,partname,vtl,cp,trn,rot,amb,dif,spc,ems,alf,shn,hashemup = T)     newcp$partid <- prta$id     compList[[compname]] <- newcp   }   addAxes(len = 50)   axes3d()   return(compList) } readCompositionFromXml <- function(stldir,xfname) {   compList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- gsub("\\-\\d$","",compname)     cp <- list()     cp$compname <- compname     cp$partname <- needpart     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       cp$rot <- round(rot,4)       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000.0*as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       cp$trn <- trn       cp$id <- 100*(length(compList)+1)       compList[[compname]] <- cp     }   }   return(compList) } readMaterialsFromXml <- function(stldir,xfname) {   partAttList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     partname <- xml_attr(it,"name")     prt <- list()     prt$partname <- partname     if (!is.null(prt)) {       print(sprintf("Part:%s",partname))       nod <- xml_find_first(it,".//*[local-name()='Ambient']")       prt$ambient <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Diffuse']")       prt$diffuse <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Specular']")       prt$specular <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Emissive']")       prt$emissive <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Shininess']")       prt$shinyness <- as.numeric(xml_text(nod))       print(sprintf("   amb - %.3f",prt$ambient))       print(sprintf("   dif - %.3f",prt$diffuse))       print(sprintf("   spc - %.3f",prt$specular))       print(sprintf("   emi - %.3f",prt$emissive))       print(sprintf("   shn - %.3f",prt$shinyness))       prt$id <- 100*(length(partAttList)+1)       partAttList[[partname]] <- prt     }   }   return(partAttList) } dumpCompList <- function(compList) {   for (cp in compList) {     print(sprintf("%s - %s",cp$compname,cp$partname))     print(cp$rot)     print(cp$trn)   } } findBBox <- function(ptmat,printword = "test",print = T) {   minx <- miny <- minz <- +9e99   maxx <- maxy <- maxz <- -9e99   for (i in 1:dim(ptmat)[2]) {     minx <- min(minx,ptmat[[1,i]])     maxx <- max(maxx,ptmat[[1,i]])     miny <- min(miny,ptmat[[2,i]])     maxy <- max(maxy,ptmat[[2,i]])     minz <- min(minz,ptmat[[3,i]])     maxz <- max(maxz,ptmat[[3,i]])   }   stats <- list()   minv <- c(minx,miny,minz)   maxv <- c(maxx,maxy,maxz)   cenv <- (maxv+minv)/2   stats$minv <- minv   stats$maxv <- maxv   stats$cenv <- cenv   print(sprintf("%s bbox x: %.1f to %.1f    y: %.1f to %.1f    z: %.1f to %.1f",                   printword,minx,maxx,miny,maxy,minz,maxz))   print(sprintf("%s cenv %.1f %.1f %.1f",printword,cenv[1],cenv[2],cenv[3]))   return(stats) } translatePointsFromMatrix <- function(ptmat,trn) {   print(sprintf("Translating trn %.1f %.1f %.1f",trn[1],trn[2],trn[3]))   for (i in 1:dim(ptmat)[2]) {     ptmat[1,i] <- ptmat[1,i] + trn[1]     ptmat[2,i] <- ptmat[2,i] + trn[2]     ptmat[3,i] <- ptmat[3,i] + trn[3]   }   return(ptmat) } writeOutFiles <- function(fnameroot="crazyflie",partAttList,partVertList,compList) {   # Components   cdf <- NULL   for (c in compList) {     vs <- round(c$out_sca,5)     vt <- round(c$out_trn,5)     mr <- round(c$out_rot,5)     if (c$id == 1500) { # pcb not behaving like the rest. No idea why.       mr <- c(1,0,0, 0,1,0, 0,0,1)     }     c1df <- data.frame(id = c$id,compname = c$compname,partid=c$partid,partname = c$partname,                        sca.x = vs[1],sca.y = vs[2],sca.z = vs[3],                        trn.x = vt[1],trn.y = vt[2],trn.z = vt[3],                        rot.11 = mr[1,1],rot.12 = mr[1,2],rot.13 = mr[1,3],                        rot.21 = mr[2,1],rot.22 = mr[2,2],rot.23 = mr[2,3],                        rot.31 = mr[3,1],rot.32 = mr[3,2],rot.33 = mr[3,3]                        )     cdf <- rbind(cdf,c1df)   }   fname <- sprintf("%s-components.csv",fnameroot)   write.csv(cdf,fname,row.names = F)   # Parts   pdf <- NULL   for (p in partAttList) {     p1df <- data.frame(id = p$id,partname=p$partname,       amb.r = p$ambient[[1]],amb.g = p$ambient[[2]],amb.b = p$ambient[[3]],amb.a = p$ambient[[4]],       dif.r = p$diffuse[[1]],dif.g = p$diffuse[[2]],dif.b = p$diffuse[[3]],dif.a = p$diffuse[[4]],       spc.r = p$specular[[1]],spc.g = p$specular[[2]],spc.b = p$specular[[3]],spc.a = p$specular[[4]],       ems.r = p$emissive[[1]],ems.g = p$emissive[[2]],ems.b = p$emissive[[3]],ems.a = p$emissive[[4]],       shinyness=p$shinyness       )     pdf <- rbind(pdf,p1df)   }   fname <- sprintf("%s-parts.csv",fnameroot)   write.csv(pdf,fname,row.names = F)   # Points   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(round(c$out_vp,5)))     names(pt1df) <- c("x","y","z","w")     pt1df$id <- c$id     # only interested in writing the first component for every part     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {        ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-points.csv",fnameroot)   write.csv(ptdf,fname,row.names = F)   # VertsIdx   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(c$out_vi))     names(pt1df) <- c("v1","v2","v3")     pt1df$id <- c$id     pt1df$partid <- c$id     # only write out the first ones     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {       ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-vertidx.csv",fnameroot)   write.csv(ptdf,fname,row.names = F) } # Start of actual program # ======================= starttime <- Sys.time() stldir <- "../Crazyflie-CAD/STL" # Get the STL files with the vertices and read them in stlfiles <- list.files(stldir,"\\.STL$") partVertList <- list() for (fname in stlfiles) {   partVertList <- readVertsFromStl(stldir,fname,partVertList) } # Now read the composistion file which has the part instances,  #  their transformations which position them, and their material properties #  compList <- readCompositionFromXml(stldir,"Crazyflie_assembly.xml") compList <- compList[order(sapply(compList,'[[',"compname"))]  # order them partAttList <- readMaterialsFromXml(stldir,"Crazyflie_assembly.xml") partAttList <- partAttList[order(sapply(partAttList,'[[',"partname"))] # order them compList <- plotWholeThing(partAttList,partVertList,compList) writeOutFiles("crazyflie",partAttList,partVertList,compList) elap <- as.numeric((Sys.time() - starttime)[1], units = "secs") print(sprintf("Run took %.1f secs for %d verts - verts optimized away:%d", elap,nvtot,nvsaved))
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
writeOutFiles("crazyflie",partAttList,partVertList,compList)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   shade3d(mesh,color = clr ,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
?gsub
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 1600 | cid == 300) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 1100 | cid == 400) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 100 | cid == 500) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 200 | cid == 600) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 1600 | cid == 400) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 1600 | cid == 300) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 1600 | cid == 500) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 1100 | cid == 300) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   if (cid == 100 | cid == 500) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to plot CAD model of CrazyFlie mini-drone # #  It performs the following septs #   1. read in STL files from local copy of github repository Crazyflie-CAD #   2. create optimized triangle meshes out of it (optimized in reducing the number of points) #   3. orienting the data so it has the right x,y,z orientation #   4. ploting in in rgl #   5. writing out the data in a small set of csv files #   appendListAsSubEl <- function(vlist,v) {   # Append a list to a list as a sub-element    # i.e. do not merge the lists (thus losing structure)   # and retain the top list's attributes    if (!is.null(v)) {     vlist[[length(vlist) + 1]] <- v     # Note, if we use the faster method below, we loose the attributes of vlist!     # Bad, bad, bad...     # vlist <- c(vlist,v)   }   return(vlist) } extractVert <- function(line) {   rv <- c(0,0,0)   sar <- str_split(line,"[\\s]")[[1]] # only one element in line   n <- length(sar)   if (n >= 3) {     rv <- c(as.numeric(sar[[n-2]]),as.numeric(sar[[n-1]]),as.numeric(sar[[n]]))   }   return(rv) } readVertsFromStl <- function(stldir, stlfname,vertPartList) {   starttime <- Sys.time()   if (!is.null(stldir) & stldir!="") {     stlfname <- sprintf("%s/%s", stldir, stlfname)   }   lines <- readLines(stlfname, warn = F)   nlines0 <- length(lines)   if (nlines0 < 6) {     print(sprintf("File too short:%d", length(nlines0)))     return(NULL)   }   print(sprintf("Read %d lines from %s",nlines0,stlfname))   vertPtList <- list()   # extract the first line which is the name of the part   partname <- lines[[1]]   partname <- gsub("solid ","",partname)   partname <- gsub("_Default_sldprt","",partname)   lines <- lines[2:length(lines)]   # trim out stuff we do not need   lines <- lines[!str_detect(lines,"outer loop")]   lines <- lines[!str_detect(lines,"endloop")]   lines <- lines[!str_detect(lines,"endfacet")]   lines <- lines[!str_detect(lines, "endsolid")]   print(sprintf("Stripped out %d irrelevant lines", nlines0-length(lines)))   # now loop over what is left and accumulate the facet vector   facetvek <- list()   for (line in lines) {     if (str_detect(line, "facet")) {       if (length(facetvek) == 4) {         vertPtList <- appendListAsSubEl(vertPtList,facetvek)       }       facetvek <- list()       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else if (str_detect(line, "vertex")) {       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else {       print(sprintf("opps unknown linetype:%s",line))     }   }   vertPtList <- appendListAsSubEl(vertPtList,facetvek) # add the remaining one tp vertPtList   vertTopList <- list()   vertTopList$vertPtList <- vertPtList   vertTopList$partname <- partname   vertPartList[[partname]] <- vertTopList   elap <- as.numeric((Sys.time() - starttime)[1], units = "secs")   print(sprintf("Extracted %d vertices in %.1f secs for part '%s'", length(vertPtList),elap,partname))   return(vertPartList) } # hash bookkeeping vhashtab <- hash() nvsaved <- 0 nvtot <- 0 addVertHashed <- function(mList,v,n = NULL) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   vkey <- paste0(sprintf("%e",v),collapse=",")   if (has.key(vkey,vhashtab)) {     vval <- vhashtab[[vkey]]     #print(sprintf("np:%d ni:%d vkey:%s nval:%d",np,ni,vkey,nval))     mList$idxList <- c(mList$idxList,vval$vnum)     if (!is.null(n)) {       vval$norm <- vval$norm + n     }     nvsaved <<- nvsaved+1   } else {     vnum <- (np + 3) / 3     vval <- list()     vval$vnum <- vnum     if (!is.null(n)) vval$norm <- n     vhashtab[vkey] <- vval     mList$pntList <- c(mList$pntList,v[1],v[2],v[3])     mList$idxList <- c(mList$idxList,vnum)     nvtot <<- nvtot+1   }   return(mList) } addVert <- function(mList,v,n = NULL) {   # no hashing   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList <- c(mList$pntList, v[1],v[2],v[3])   mList$idxList <- c(mList$idxList, ni+1)   nvtot <<- nvtot+1   return(mList) } addTri <- function(mList,v1,v2,v3,norm,hashemup=T) {   if (hashemup) {     mList <- addVertHashed(mList,v1,norm)     mList <- addVertHashed(mList,v2,norm)     mList <- addVertHashed(mList,v3,norm)   } else {     mList <- addVert(mList,v1,norm)     mList <- addVert(mList,v2,norm)     mList <- addVert(mList,v3,norm)   }   return(mList) } normalize <- function(n) {   vlen <- sqrt(n[[1]]^2 + n[[2]]^2 + n[[3]]^2)   if (vlen>0) {     n <- n/vlen   }   return(n) } plotPartAsMesh <- function(compname,partname,vertTopList,comp,trn = c(0,0,0),rot = NULL,                            amb = "silver",dif=NULL,spc=NULL,ems=NULL,alf = 1,shiny = 50,donorms = F,hashemup = T) {   vhashtab <<- hash()   vertPtList <- vertTopList$vertPtList   mList <- list()   mList$idxList <- list()   mList$pntList <- list()   mList$nrmList <- list()   normval <- NULL   for (v in vertPtList) {     if (length(v) == 4) {       if (donorms) normval <- v[[1]]       mList <- addTri(mList,v[[2]],v[[3]],v[[4]],normval,hashemup=hashemup)      }   }   vidx <- unlist(mList$idxList)   vpnt <- unlist(mList$pntList)   nv <- length(vertPtList)   ni <- length(vidx)   np <- length(vpnt)   # Not sure I can make donorms work right   # giving up for now - 2016.12.1   #   if (donorms) {     nn <- np / 3     for (i in 1:nn) {       bidx <- (i-1)*3       v1 <- vpnt[[bidx+1]]       v2 <- vpnt[[bidx+2]]       v3 <- vpnt[[bidx+3]]       v <- c(v1,v2,v3)       vkey <- paste0(sprintf("%e",v),collapse = ",")       vval <- vhashtab[[vkey]]       mList$nrmList <- c(mList$nrmList,normalize(vval$norm))     }     vnrm <- unlist(mList$nrmList)   }   nvsv <- 3*nv - np   print(sprintf("   tmesh3d - nv:%d np:%d ni:%d maxi:%d mini:%d - vsaved:%d",nv,np,ni,max(vidx),min(vidx),nvsv))   if (donorms) {     part <- tmesh3d(vpnt,vidx,homogeneous=F, normals=vnrm)   } else {     part <- tmesh3d(vpnt,vidx,homogeneous=F)   }   part <- translate3d(rotate3d(part,matrix = rot),trn[[1]],trn[[2]],trn[[3]])   # Center and orient the drone - determined these from the data   # Drone was upside down and facing the wrong way   # making the center to be the center of the pcb board   #   pcbcen <- -0.5*c(54.09200, 71.18820, 75.60720)   part <- translate3d(part,pcbcen[[1]],pcbcen[[2]],pcbcen[[3]])   part <- rotate3d(part,pi,0,1,0 ) # rotate 180 around the y-axis   calccog <- T   if (calccog) {     vb <- part$vb     nvb <- length(vb)     bsq <- (1:(nvb/4) - 1)*4     xc <- vb[bsq + 1]     yc <- vb[bsq + 2]     zc <- vb[bsq + 3]     wc <- vb[bsq + 4]     cx <- mean(min(xc) + max(xc))     cy <- mean(min(yc) + max(yc))     cz <- mean(min(zc) + max(zc))     cw <- mean(min(wc) + max(wc))     tx <- max(xc) - min(xc)     ty <- max(yc) - min(yc)     tz <- max(zc) - min(zc)     tw <- max(wc) - min(wc)     print(sprintf("   cog:%.5f %.5f %.5f %.5f thickness: %.5f %.5f %.5f %.5f",cx,cy,cz,cw,tx,ty,tz,tw))   }   #rgl.material(color=amb,alpha=alf,specular=spc,shininess=shiny)   #shade3d(part)   shade3d(part,color = amb,specular=spc,emissive=ems,alpha = alf,shiny = shiny)   comp$out_vp <- part$vb   comp$out_vi <- part$it   stats <- findBBox(comp$out_vp,compname)   comp$out_vp <- translatePointsFromMatrix(comp$out_vp, -stats$cenv )   comp$out_sca <- c(1,1,1)   # I don't know why this transformation of rot is necessary, but it is..   # m1 swaps Y&Z and then inverts all the axes   #   m1 <- matrix(c(-1,0,0,0,0,-1,0,-1,0),3,3)   comp$out_rot <- m1 %*% rot   comp$out_trn <- stats$cenv   stats <- findBBox(comp$out_vp,compname)   #comp$out_trn <- c(0,0,0)   return(comp) } addAxes <- function(len = 1) {   u <- c(0,1)*len   v <- c(0,0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u,v,w,c("","X"),color=c("red"))   lines3d(w,u,v,color=c("green"))   text3d(w,u,v,c("","Y"),color=c("green"))   lines3d(v,w,u,color=c("blue"))   text3d(v,w,u,c("","Z"),color=c("blue")) } colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } plotWholeThing <- function(partAttList,partVertList,compList) {   for (cp in compList) {     compname <- cp$compname     partname <- gsub("\\-\\d$","",compname)     print(sprintf("Comp:%s part:%s",compname,partname))     rot <- cp$rot     trn <- cp$trn     prta <- partAttList[[partname]]     amb <- colVekToStringColor(prta$ambient)     dif <- colVekToStringColor(prta$diffuse)     spc <- colVekToStringColor(prta$specular)     ems <- colVekToStringColor(prta$emissive)     alf <- prta$ambient[4]     shn <- prta$shinyness     #print(prta$ambient)     vtl <- partVertList[[partname]]     newcp <- plotPartAsMesh(compname,partname,vtl,cp,trn,rot,amb,dif,spc,ems,alf,shn,hashemup = T)     newcp$partid <- prta$id     compList[[compname]] <- newcp   }   addAxes(len = 50)   axes3d()   return(compList) } readCompositionFromXml <- function(stldir,xfname) {   compList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- gsub("\\-\\d$","",compname)     cp <- list()     cp$compname <- compname     cp$partname <- needpart     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       cp$rot <- round(rot,4)       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000.0*as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       cp$trn <- trn       cp$id <- 100*(length(compList)+1)       compList[[compname]] <- cp     }   }   return(compList) } readMaterialsFromXml <- function(stldir,xfname) {   partAttList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     partname <- xml_attr(it,"name")     prt <- list()     prt$partname <- partname     if (!is.null(prt)) {       print(sprintf("Part:%s",partname))       nod <- xml_find_first(it,".//*[local-name()='Ambient']")       prt$ambient <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Diffuse']")       prt$diffuse <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Specular']")       prt$specular <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Emissive']")       prt$emissive <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Shininess']")       prt$shinyness <- as.numeric(xml_text(nod))       print(sprintf("   amb - %.3f",prt$ambient))       print(sprintf("   dif - %.3f",prt$diffuse))       print(sprintf("   spc - %.3f",prt$specular))       print(sprintf("   emi - %.3f",prt$emissive))       print(sprintf("   shn - %.3f",prt$shinyness))       prt$id <- 100*(length(partAttList)+1)       partAttList[[partname]] <- prt     }   }   return(partAttList) } dumpCompList <- function(compList) {   for (cp in compList) {     print(sprintf("%s - %s",cp$compname,cp$partname))     print(cp$rot)     print(cp$trn)   } } findBBox <- function(ptmat,printword = "test",print = T) {   minx <- miny <- minz <- +9e99   maxx <- maxy <- maxz <- -9e99   for (i in 1:dim(ptmat)[2]) {     minx <- min(minx,ptmat[[1,i]])     maxx <- max(maxx,ptmat[[1,i]])     miny <- min(miny,ptmat[[2,i]])     maxy <- max(maxy,ptmat[[2,i]])     minz <- min(minz,ptmat[[3,i]])     maxz <- max(maxz,ptmat[[3,i]])   }   stats <- list()   minv <- c(minx,miny,minz)   maxv <- c(maxx,maxy,maxz)   cenv <- (maxv+minv)/2   stats$minv <- minv   stats$maxv <- maxv   stats$cenv <- cenv   print(sprintf("%s bbox x: %.1f to %.1f    y: %.1f to %.1f    z: %.1f to %.1f",                   printword,minx,maxx,miny,maxy,minz,maxz))   print(sprintf("%s cenv %.1f %.1f %.1f",printword,cenv[1],cenv[2],cenv[3]))   return(stats) } translatePointsFromMatrix <- function(ptmat,trn) {   print(sprintf("Translating trn %.1f %.1f %.1f",trn[1],trn[2],trn[3]))   for (i in 1:dim(ptmat)[2]) {     ptmat[1,i] <- ptmat[1,i] + trn[1]     ptmat[2,i] <- ptmat[2,i] + trn[2]     ptmat[3,i] <- ptmat[3,i] + trn[3]   }   return(ptmat) } fixupname <- function(oname) {   name <- oname   name <- gsub("motor mount-1","motor mount-1",name)   name <- gsub("motor mount-3","motor mount-2",name)   name <- gsub("motor mount-4","motor mount-3",name)   name <- gsub("motor mount-5","motor mount-4",name)   name <- gsub("motor-1","motor---2",name)   name <- gsub("motor-3","motor---1",name)   name <- gsub("motor-2","motor---4",name)   name <- gsub("motor-4","motor---3",name)   name <- gsub("---","-",name)   return(name) } writeOutFiles <- function(fnameroot="crazyflie",partAttList,partVertList,compList) {   # Components   cdf <- NULL   for (c in compList) {     vs <- round(c$out_sca,5)     vt <- round(c$out_trn,5)     mr <- round(c$out_rot,5)     if (c$id == 1500) { # pcb not behaving like the rest. No idea why.       mr <- matrix(c(1,0,0, 0,1,0, 0,0,1),3,3)     }     fixcompname <- fixupname(c$compname)     c1df <- data.frame(id = c$id,compname = fixcompname,partid=c$partid,partname = c$partname,                        sca.x = vs[1],sca.y = vs[2],sca.z = vs[3],                        trn.x = vt[1],trn.y = vt[2],trn.z = vt[3],                        rot.11 = mr[1,1],rot.12 = mr[1,2],rot.13 = mr[1,3],                        rot.21 = mr[2,1],rot.22 = mr[2,2],rot.23 = mr[2,3],                        rot.31 = mr[3,1],rot.32 = mr[3,2],rot.33 = mr[3,3]                        )     cdf <- rbind(cdf,c1df)   }   fname <- sprintf("%s-components.csv",fnameroot)   write.csv(cdf,fname,row.names = F)   # Parts   pdf <- NULL   for (p in partAttList) {     p1df <- data.frame(id = p$id,partname=p$partname,       amb.r = p$ambient[[1]],amb.g = p$ambient[[2]],amb.b = p$ambient[[3]],amb.a = p$ambient[[4]],       dif.r = p$diffuse[[1]],dif.g = p$diffuse[[2]],dif.b = p$diffuse[[3]],dif.a = p$diffuse[[4]],       spc.r = p$specular[[1]],spc.g = p$specular[[2]],spc.b = p$specular[[3]],spc.a = p$specular[[4]],       ems.r = p$emissive[[1]],ems.g = p$emissive[[2]],ems.b = p$emissive[[3]],ems.a = p$emissive[[4]],       shinyness=p$shinyness       )     pdf <- rbind(pdf,p1df)   }   fname <- sprintf("%s-parts.csv",fnameroot)   write.csv(pdf,fname,row.names = F)   # Points   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(round(c$out_vp,5)))     names(pt1df) <- c("x","y","z","w")     pt1df$id <- c$id     # only interested in writing the first component for every part     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {        ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-points.csv",fnameroot)   write.csv(ptdf,fname,row.names = F)   # VertsIdx   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(c$out_vi))     names(pt1df) <- c("v1","v2","v3")     pt1df$id <- c$id     pt1df$partid <- c$id     # only write out the first ones     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {       ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-vertidx.csv",fnameroot)   write.csv(ptdf,fname,row.names = F) } # Start of actual program # ======================= starttime <- Sys.time() stldir <- "../Crazyflie-CAD/STL" # Get the STL files with the vertices and read them in stlfiles <- list.files(stldir,"\\.STL$") partVertList <- list() for (fname in stlfiles) {   partVertList <- readVertsFromStl(stldir,fname,partVertList) } # Now read the composistion file which has the part instances,  #  their transformations which position them, and their material properties #  compList <- readCompositionFromXml(stldir,"Crazyflie_assembly.xml") compList <- compList[order(sapply(compList,'[[',"compname"))]  # order them partAttList <- readMaterialsFromXml(stldir,"Crazyflie_assembly.xml") partAttList <- partAttList[order(sapply(partAttList,'[[',"partname"))] # order them compList <- plotWholeThing(partAttList,partVertList,compList) writeOutFiles("crazyflie",partAttList,partVertList,compList) elap <- as.numeric((Sys.time() - starttime)[1], units = "secs") print(sprintf("Run took %.1f secs for %d verts - verts optimized away:%d", elap,nvtot,nvsaved))
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 300   # 2 1100 400   # 3 100 500   # 4 200 600   if (cid == 1600 | cid == 300) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 300   # 2 1100 400   # 3 100 500   # 4 200 600   if (cid == 1600 | cid == 300) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 300   # 2 1100 400   # 3 100 500   # 4 200 600   if (cid == 1600 | cid == 500) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 500   # 2 1100 300   # 3 100 500   # 4 200 600   if (cid == 1100 | cid == 300) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 500   # 2 1100 300   # 3 100 600   # 4 200 600   if (cid == 100 | cid == 600) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 500   # 2 1100 300   # 3 100 600   # 4 200 400   if (cid == 200 | cid == 400) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
cdf$compname
order(cdf$compname)
order(as.character(cdf$compname))
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 500   # 2 1100 300   # 3 100 600   # 4 200 400   if (cid == 200 | cid == 400) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 500   # 2 1100 300   # 3 100 600   # 4 200 400   if (cid == 1600 | cid == 500) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 500   # 2 1100 300   # 3 100 600   # 4 200 400   if (cid == 1100 | cid == 300) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # 1 1600 500   # 2 1100 300   # 3 100 600   # 4 200 400   if (cid == 200 | cid == 400) {     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   }   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == fcid,]   pt1df$id <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$id == fcid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   print(sprintf("     maxidx:%d  sollmax:%.3f",max(mvi),length(mpt)/3))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to plot CAD model of CrazyFlie mini-drone # #  It performs the following septs #   1. read in STL files from local copy of github repository Crazyflie-CAD #   2. create optimized triangle meshes out of it (optimized in reducing the number of points) #   3. orienting the data so it has the right x,y,z orientation #   4. ploting in in rgl #   5. writing out the data in a small set of csv files #   appendListAsSubEl <- function(vlist,v) {   # Append a list to a list as a sub-element    # i.e. do not merge the lists (thus losing structure)   # and retain the top list's attributes    if (!is.null(v)) {     vlist[[length(vlist) + 1]] <- v     # Note, if we use the faster method below, we loose the attributes of vlist!     # Bad, bad, bad...     # vlist <- c(vlist,v)   }   return(vlist) } extractVert <- function(line) {   rv <- c(0,0,0)   sar <- str_split(line,"[\\s]")[[1]] # only one element in line   n <- length(sar)   if (n >= 3) {     rv <- c(as.numeric(sar[[n-2]]),as.numeric(sar[[n-1]]),as.numeric(sar[[n]]))   }   return(rv) } readVertsFromStl <- function(stldir, stlfname,vertPartList) {   starttime <- Sys.time()   if (!is.null(stldir) & stldir!="") {     stlfname <- sprintf("%s/%s", stldir, stlfname)   }   lines <- readLines(stlfname, warn = F)   nlines0 <- length(lines)   if (nlines0 < 6) {     print(sprintf("File too short:%d", length(nlines0)))     return(NULL)   }   print(sprintf("Read %d lines from %s",nlines0,stlfname))   vertPtList <- list()   # extract the first line which is the name of the part   partname <- lines[[1]]   partname <- gsub("solid ","",partname)   partname <- gsub("_Default_sldprt","",partname)   lines <- lines[2:length(lines)]   # trim out stuff we do not need   lines <- lines[!str_detect(lines,"outer loop")]   lines <- lines[!str_detect(lines,"endloop")]   lines <- lines[!str_detect(lines,"endfacet")]   lines <- lines[!str_detect(lines, "endsolid")]   print(sprintf("Stripped out %d irrelevant lines", nlines0-length(lines)))   # now loop over what is left and accumulate the facet vector   facetvek <- list()   for (line in lines) {     if (str_detect(line, "facet")) {       if (length(facetvek) == 4) {         vertPtList <- appendListAsSubEl(vertPtList,facetvek)       }       facetvek <- list()       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else if (str_detect(line, "vertex")) {       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else {       print(sprintf("opps unknown linetype:%s",line))     }   }   vertPtList <- appendListAsSubEl(vertPtList,facetvek) # add the remaining one tp vertPtList   vertTopList <- list()   vertTopList$vertPtList <- vertPtList   vertTopList$partname <- partname   vertPartList[[partname]] <- vertTopList   elap <- as.numeric((Sys.time() - starttime)[1], units = "secs")   print(sprintf("Extracted %d vertices in %.1f secs for part '%s'", length(vertPtList),elap,partname))   return(vertPartList) } # hash bookkeeping vhashtab <- hash() nvsaved <- 0 nvtot <- 0 addVertHashed <- function(mList,v,n = NULL) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   vkey <- paste0(sprintf("%e",v),collapse=",")   if (has.key(vkey,vhashtab)) {     vval <- vhashtab[[vkey]]     #print(sprintf("np:%d ni:%d vkey:%s nval:%d",np,ni,vkey,nval))     mList$idxList <- c(mList$idxList,vval$vnum)     if (!is.null(n)) {       vval$norm <- vval$norm + n     }     nvsaved <<- nvsaved+1   } else {     vnum <- (np + 3) / 3     vval <- list()     vval$vnum <- vnum     if (!is.null(n)) vval$norm <- n     vhashtab[vkey] <- vval     mList$pntList <- c(mList$pntList,v[1],v[2],v[3])     mList$idxList <- c(mList$idxList,vnum)     nvtot <<- nvtot+1   }   return(mList) } addVert <- function(mList,v,n = NULL) {   # no hashing   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList <- c(mList$pntList, v[1],v[2],v[3])   mList$idxList <- c(mList$idxList, ni+1)   nvtot <<- nvtot+1   return(mList) } addTri <- function(mList,v1,v2,v3,norm,hashemup=T) {   if (hashemup) {     mList <- addVertHashed(mList,v1,norm)     mList <- addVertHashed(mList,v2,norm)     mList <- addVertHashed(mList,v3,norm)   } else {     mList <- addVert(mList,v1,norm)     mList <- addVert(mList,v2,norm)     mList <- addVert(mList,v3,norm)   }   return(mList) } normalize <- function(n) {   vlen <- sqrt(n[[1]]^2 + n[[2]]^2 + n[[3]]^2)   if (vlen>0) {     n <- n/vlen   }   return(n) } plotPartAsMesh <- function(compname,partname,vertTopList,comp,trn = c(0,0,0),rot = NULL,                            amb = "silver",dif=NULL,spc=NULL,ems=NULL,alf = 1,shiny = 50,donorms = F,hashemup = T) {   vhashtab <<- hash()   vertPtList <- vertTopList$vertPtList   mList <- list()   mList$idxList <- list()   mList$pntList <- list()   mList$nrmList <- list()   normval <- NULL   for (v in vertPtList) {     if (length(v) == 4) {       if (donorms) normval <- v[[1]]       mList <- addTri(mList,v[[2]],v[[3]],v[[4]],normval,hashemup=hashemup)      }   }   vidx <- unlist(mList$idxList)   vpnt <- unlist(mList$pntList)   nv <- length(vertPtList)   ni <- length(vidx)   np <- length(vpnt)   # Not sure I can make donorms work right   # giving up for now - 2016.12.1   #   if (donorms) {     nn <- np / 3     for (i in 1:nn) {       bidx <- (i-1)*3       v1 <- vpnt[[bidx+1]]       v2 <- vpnt[[bidx+2]]       v3 <- vpnt[[bidx+3]]       v <- c(v1,v2,v3)       vkey <- paste0(sprintf("%e",v),collapse = ",")       vval <- vhashtab[[vkey]]       mList$nrmList <- c(mList$nrmList,normalize(vval$norm))     }     vnrm <- unlist(mList$nrmList)   }   nvsv <- 3*nv - np   print(sprintf("   tmesh3d - nv:%d np:%d ni:%d maxi:%d mini:%d - vsaved:%d",nv,np,ni,max(vidx),min(vidx),nvsv))   if (donorms) {     part <- tmesh3d(vpnt,vidx,homogeneous=F, normals=vnrm)   } else {     part <- tmesh3d(vpnt,vidx,homogeneous=F)   }   part <- translate3d(rotate3d(part,matrix = rot),trn[[1]],trn[[2]],trn[[3]])   # Center and orient the drone - determined these from the data   # Drone was upside down and facing the wrong way   # making the center to be the center of the pcb board   #   pcbcen <- -0.5*c(54.09200, 71.18820, 75.60720)   part <- translate3d(part,pcbcen[[1]],pcbcen[[2]],pcbcen[[3]])   part <- rotate3d(part,pi,0,1,0 ) # rotate 180 around the y-axis   calccog <- T   if (calccog) {     vb <- part$vb     nvb <- length(vb)     bsq <- (1:(nvb/4) - 1)*4     xc <- vb[bsq + 1]     yc <- vb[bsq + 2]     zc <- vb[bsq + 3]     wc <- vb[bsq + 4]     cx <- mean(min(xc) + max(xc))     cy <- mean(min(yc) + max(yc))     cz <- mean(min(zc) + max(zc))     cw <- mean(min(wc) + max(wc))     tx <- max(xc) - min(xc)     ty <- max(yc) - min(yc)     tz <- max(zc) - min(zc)     tw <- max(wc) - min(wc)     print(sprintf("   cog:%.5f %.5f %.5f %.5f thickness: %.5f %.5f %.5f %.5f",cx,cy,cz,cw,tx,ty,tz,tw))   }   #rgl.material(color=amb,alpha=alf,specular=spc,shininess=shiny)   #shade3d(part)   shade3d(part,color = amb,specular=spc,emissive=ems,alpha = alf,shiny = shiny)   comp$out_vp <- part$vb   comp$out_vi <- part$it   stats <- findBBox(comp$out_vp,compname)   comp$out_vp <- translatePointsFromMatrix(comp$out_vp, -stats$cenv )   comp$out_sca <- c(1,1,1)   # I don't know why this transformation of rot is necessary, but it is..   # m1 swaps Y&Z and then inverts all the axes   #   m1 <- matrix(c(-1,0,0,0,0,-1,0,-1,0),3,3)   comp$out_rot <- m1 %*% rot   comp$out_trn <- stats$cenv   stats <- findBBox(comp$out_vp,compname)   #comp$out_trn <- c(0,0,0)   return(comp) } addAxes <- function(len = 1) {   u <- c(0,1)*len   v <- c(0,0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u,v,w,c("","X"),color=c("red"))   lines3d(w,u,v,color=c("green"))   text3d(w,u,v,c("","Y"),color=c("green"))   lines3d(v,w,u,color=c("blue"))   text3d(v,w,u,c("","Z"),color=c("blue")) } colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } plotWholeThing <- function(partAttList,partVertList,compList) {   for (cp in compList) {     compname <- cp$compname     partname <- gsub("\\-\\d$","",compname)     print(sprintf("Comp:%s part:%s",compname,partname))     rot <- cp$rot     trn <- cp$trn     prta <- partAttList[[partname]]     amb <- colVekToStringColor(prta$ambient)     dif <- colVekToStringColor(prta$diffuse)     spc <- colVekToStringColor(prta$specular)     ems <- colVekToStringColor(prta$emissive)     alf <- prta$ambient[4]     shn <- prta$shinyness     #print(prta$ambient)     vtl <- partVertList[[partname]]     newcp <- plotPartAsMesh(compname,partname,vtl,cp,trn,rot,amb,dif,spc,ems,alf,shn,hashemup = T)     newcp$partid <- prta$id     compList[[compname]] <- newcp   }   addAxes(len = 50)   axes3d()   return(compList) } readCompositionFromXml <- function(stldir,xfname) {   compList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- gsub("\\-\\d$","",compname)     cp <- list()     cp$compname <- compname     cp$partname <- needpart     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       cp$rot <- round(rot,4)       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000.0*as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       cp$trn <- trn       cp$id <- 100*(length(compList)+1)       compList[[compname]] <- cp     }   }   return(compList) } readMaterialsFromXml <- function(stldir,xfname) {   partAttList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     partname <- xml_attr(it,"name")     prt <- list()     prt$partname <- partname     if (!is.null(prt)) {       print(sprintf("Part:%s",partname))       nod <- xml_find_first(it,".//*[local-name()='Ambient']")       prt$ambient <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Diffuse']")       prt$diffuse <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Specular']")       prt$specular <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Emissive']")       prt$emissive <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Shininess']")       prt$shinyness <- as.numeric(xml_text(nod))       print(sprintf("   amb - %.3f",prt$ambient))       print(sprintf("   dif - %.3f",prt$diffuse))       print(sprintf("   spc - %.3f",prt$specular))       print(sprintf("   emi - %.3f",prt$emissive))       print(sprintf("   shn - %.3f",prt$shinyness))       prt$id <- 100*(length(partAttList)+1)       partAttList[[partname]] <- prt     }   }   return(partAttList) } dumpCompList <- function(compList) {   for (cp in compList) {     print(sprintf("%s - %s",cp$compname,cp$partname))     print(cp$rot)     print(cp$trn)   } } findBBox <- function(ptmat,printword = "test",print = T) {   minx <- miny <- minz <- +9e99   maxx <- maxy <- maxz <- -9e99   for (i in 1:dim(ptmat)[2]) {     minx <- min(minx,ptmat[[1,i]])     maxx <- max(maxx,ptmat[[1,i]])     miny <- min(miny,ptmat[[2,i]])     maxy <- max(maxy,ptmat[[2,i]])     minz <- min(minz,ptmat[[3,i]])     maxz <- max(maxz,ptmat[[3,i]])   }   stats <- list()   minv <- c(minx,miny,minz)   maxv <- c(maxx,maxy,maxz)   cenv <- (maxv+minv)/2   stats$minv <- minv   stats$maxv <- maxv   stats$cenv <- cenv   print(sprintf("%s bbox x: %.1f to %.1f    y: %.1f to %.1f    z: %.1f to %.1f",                   printword,minx,maxx,miny,maxy,minz,maxz))   print(sprintf("%s cenv %.1f %.1f %.1f",printword,cenv[1],cenv[2],cenv[3]))   return(stats) } translatePointsFromMatrix <- function(ptmat,trn) {   print(sprintf("Translating trn %.1f %.1f %.1f",trn[1],trn[2],trn[3]))   for (i in 1:dim(ptmat)[2]) {     ptmat[1,i] <- ptmat[1,i] + trn[1]     ptmat[2,i] <- ptmat[2,i] + trn[2]     ptmat[3,i] <- ptmat[3,i] + trn[3]   }   return(ptmat) } fixupname <- function(oname) {   name <- oname   name <- gsub("motor mount-1","motor mount-1",name)   name <- gsub("motor mount-3","motor mount-2",name)   name <- gsub("motor mount-4","motor mount-3",name)   name <- gsub("motor mount-5","motor mount-4",name)   name <- gsub("motor-1","motor---2",name)   name <- gsub("motor-3","motor---1",name)   name <- gsub("motor-2","motor---4",name)   name <- gsub("motor-4","motor---3",name)   name <- gsub("---","-",name)   return(name) } writeOutFiles <- function(fnameroot="crazyflie",partAttList,partVertList,compList) {   # Components   cdf <- NULL   for (c in compList) {     vs <- round(c$out_sca,5)     vt <- round(c$out_trn,5)     mr <- round(c$out_rot,5)     if (c$id == 1500) { # pcb not behaving like the rest. No idea why.       mr <- matrix(c(1,0,0, 0,1,0, 0,0,1),3,3)     }     fixcompname <- fixupname(c$compname)     c1df <- data.frame(id = c$id,compname = fixcompname,partid=c$partid,partname = c$partname,                        sca.x = vs[1],sca.y = vs[2],sca.z = vs[3],                        trn.x = vt[1],trn.y = vt[2],trn.z = vt[3],                        rot.11 = mr[1,1],rot.12 = mr[1,2],rot.13 = mr[1,3],                        rot.21 = mr[2,1],rot.22 = mr[2,2],rot.23 = mr[2,3],                        rot.31 = mr[3,1],rot.32 = mr[3,2],rot.33 = mr[3,3]                        )     cdf <- rbind(cdf,c1df)   }   cdf <- cdf[order(as.character(cdf$compname)),]   fname <- sprintf("%s-components.csv",fnameroot)   write.csv(cdf,fname,row.names = F)   # Parts   pdf <- NULL   for (p in partAttList) {     p1df <- data.frame(id = p$id,partname=p$partname,       amb.r = p$ambient[[1]],amb.g = p$ambient[[2]],amb.b = p$ambient[[3]],amb.a = p$ambient[[4]],       dif.r = p$diffuse[[1]],dif.g = p$diffuse[[2]],dif.b = p$diffuse[[3]],dif.a = p$diffuse[[4]],       spc.r = p$specular[[1]],spc.g = p$specular[[2]],spc.b = p$specular[[3]],spc.a = p$specular[[4]],       ems.r = p$emissive[[1]],ems.g = p$emissive[[2]],ems.b = p$emissive[[3]],ems.a = p$emissive[[4]],       shinyness=p$shinyness       )     pdf <- rbind(pdf,p1df)   }   fname <- sprintf("%s-parts.csv",fnameroot)   write.csv(pdf,fname,row.names = F)   # Points   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(round(c$out_vp,5)))     names(pt1df) <- c("x","y","z","w")     pt1df$partid <- c$partid     # only interested in writing the first component for every part     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {        ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-points.csv",fnameroot)   write.csv(ptdf,fname,row.names = F)   # VertsIdx   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(c$out_vi))     names(pt1df) <- c("v1","v2","v3")     #pt1df$id <- c$id     pt1df$partid <- c$id     # only write out the first ones     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {       ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-vertidx.csv",fnameroot)   write.csv(ptdf,fname,row.names = F) } # Start of actual program # ======================= starttime <- Sys.time() stldir <- "../Crazyflie-CAD/STL" # Get the STL files with the vertices and read them in stlfiles <- list.files(stldir,"\\.STL$") partVertList <- list() for (fname in stlfiles) {   partVertList <- readVertsFromStl(stldir,fname,partVertList) } # Now read the composistion file which has the part instances,  #  their transformations which position them, and their material properties #  compList <- readCompositionFromXml(stldir,"Crazyflie_assembly.xml") compList <- compList[order(sapply(compList,'[[',"compname"))]  # order them partAttList <- readMaterialsFromXml(stldir,"Crazyflie_assembly.xml") partAttList <- partAttList[order(sapply(partAttList,'[[',"partname"))] # order them compList <- plotWholeThing(partAttList,partVertList,compList) writeOutFiles("crazyflie",partAttList,partVertList,compList) elap <- as.numeric((Sys.time() - starttime)[1], units = "secs") print(sprintf("Run took %.1f secs for %d verts - verts optimized away:%d", elap,nvtot,nvsaved))
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$id   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   #fcidx <- which(cdf$partname == pname)[[1]]   #fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$id == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$id   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   #fcidx <- which(cdf$partname == pname)[[1]]   #fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$id   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   #fcidx <- which(cdf$partname == pname)[[1]]   #fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$id   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$id   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$id   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$id[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   fcidx <- which(cdf$partname == pname)[[1]]   fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  fcid:%4d - cidx:%2d fcidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,fcid,cidx,fcidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   #fcidx <- which(cdf$partname == pname)[[1]]   #fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   #fcidx <- which(cdf$partname == pname)[[1]]   #fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   #fcidx <- which(cdf$partname == pname)[[1]]   #fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } ctran <- c(1,1,3,3,3,3,7,7,9,9,1,12,13,14,15,1,17) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   #fcidx <- which(cdf$partname == pname)[[1]]   #fcid <- cdf$id[fcidx]   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$id <- NULL   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$id <- NULL   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx) #  if (fcid == 1600) { #    omesh <- mesh #    omesh <- translate3d(omesh,trn[1],trn[2],trn[3]) #  }   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
?rotate3d
?scale3d
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=pi )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=pi,y=pi,z=pi )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to plot CAD model of CrazyFlie mini-drone # #  It performs the following septs #   1. read in STL files from local copy of github repository Crazyflie-CAD #   2. create optimized triangle meshes out of it (optimized in reducing the number of points) #   3. orienting the data so it has the right x,y,z orientation #   4. ploting in in rgl #   5. writing out the data in a small set of csv files #   appendListAsSubEl <- function(vlist,v) {   # Append a list to a list as a sub-element    # i.e. do not merge the lists (thus losing structure)   # and retain the top list's attributes    if (!is.null(v)) {     vlist[[length(vlist) + 1]] <- v     # Note, if we use the faster method below, we loose the attributes of vlist!     # Bad, bad, bad...     # vlist <- c(vlist,v)   }   return(vlist) } extractVert <- function(line) {   rv <- c(0,0,0)   sar <- str_split(line,"[\\s]")[[1]] # only one element in line   n <- length(sar)   if (n >= 3) {     rv <- c(as.numeric(sar[[n-2]]),as.numeric(sar[[n-1]]),as.numeric(sar[[n]]))   }   return(rv) } readVertsFromStl <- function(stldir, stlfname,vertPartList) {   starttime <- Sys.time()   if (!is.null(stldir) & stldir!="") {     stlfname <- sprintf("%s/%s", stldir, stlfname)   }   lines <- readLines(stlfname, warn = F)   nlines0 <- length(lines)   if (nlines0 < 6) {     print(sprintf("File too short:%d", length(nlines0)))     return(NULL)   }   print(sprintf("Read %d lines from %s",nlines0,stlfname))   vertPtList <- list()   # extract the first line which is the name of the part   partname <- lines[[1]]   partname <- gsub("solid ","",partname)   partname <- gsub("_Default_sldprt","",partname)   lines <- lines[2:length(lines)]   # trim out stuff we do not need   lines <- lines[!str_detect(lines,"outer loop")]   lines <- lines[!str_detect(lines,"endloop")]   lines <- lines[!str_detect(lines,"endfacet")]   lines <- lines[!str_detect(lines, "endsolid")]   print(sprintf("Stripped out %d irrelevant lines", nlines0-length(lines)))   # now loop over what is left and accumulate the facet vector   facetvek <- list()   for (line in lines) {     if (str_detect(line, "facet")) {       if (length(facetvek) == 4) {         vertPtList <- appendListAsSubEl(vertPtList,facetvek)       }       facetvek <- list()       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else if (str_detect(line, "vertex")) {       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else {       print(sprintf("opps unknown linetype:%s",line))     }   }   vertPtList <- appendListAsSubEl(vertPtList,facetvek) # add the remaining one tp vertPtList   vertTopList <- list()   vertTopList$vertPtList <- vertPtList   vertTopList$partname <- partname   vertPartList[[partname]] <- vertTopList   elap <- as.numeric((Sys.time() - starttime)[1], units = "secs")   print(sprintf("Extracted %d vertices in %.1f secs for part '%s'", length(vertPtList),elap,partname))   return(vertPartList) } # hash bookkeeping vhashtab <- hash() nvsaved <- 0 nvtot <- 0 addVertHashed <- function(mList,v,n = NULL) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   vkey <- paste0(sprintf("%e",v),collapse=",")   if (has.key(vkey,vhashtab)) {     vval <- vhashtab[[vkey]]     #print(sprintf("np:%d ni:%d vkey:%s nval:%d",np,ni,vkey,nval))     mList$idxList <- c(mList$idxList,vval$vnum)     if (!is.null(n)) {       vval$norm <- vval$norm + n     }     nvsaved <<- nvsaved+1   } else {     vnum <- (np + 3) / 3     vval <- list()     vval$vnum <- vnum     if (!is.null(n)) vval$norm <- n     vhashtab[vkey] <- vval     mList$pntList <- c(mList$pntList,v[1],v[2],v[3])     mList$idxList <- c(mList$idxList,vnum)     nvtot <<- nvtot+1   }   return(mList) } addVert <- function(mList,v,n = NULL) {   # no hashing   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList <- c(mList$pntList, v[1],v[2],v[3])   mList$idxList <- c(mList$idxList, ni+1)   nvtot <<- nvtot+1   return(mList) } addTri <- function(mList,v1,v2,v3,norm,hashemup=T) {   if (hashemup) {     mList <- addVertHashed(mList,v1,norm)     mList <- addVertHashed(mList,v2,norm)     mList <- addVertHashed(mList,v3,norm)   } else {     mList <- addVert(mList,v1,norm)     mList <- addVert(mList,v2,norm)     mList <- addVert(mList,v3,norm)   }   return(mList) } normalize <- function(n) {   vlen <- sqrt(n[[1]]^2 + n[[2]]^2 + n[[3]]^2)   if (vlen>0) {     n <- n/vlen   }   return(n) } plotPartAsMesh <- function(compname,partname,vertTopList,comp,trn = c(0,0,0),rot = NULL,                            amb = "silver",dif=NULL,spc=NULL,ems=NULL,alf = 1,shiny = 50,donorms = F,hashemup = T) {   vhashtab <<- hash()   vertPtList <- vertTopList$vertPtList   mList <- list()   mList$idxList <- list()   mList$pntList <- list()   mList$nrmList <- list()   normval <- NULL   for (v in vertPtList) {     if (length(v) == 4) {       if (donorms) normval <- v[[1]]       mList <- addTri(mList,v[[2]],v[[3]],v[[4]],normval,hashemup=hashemup)      }   }   vidx <- unlist(mList$idxList)   vpnt <- unlist(mList$pntList)   nv <- length(vertPtList)   ni <- length(vidx)   np <- length(vpnt)   # Not sure I can make donorms work right   # giving up for now - 2016.12.1   #   if (donorms) {     nn <- np / 3     for (i in 1:nn) {       bidx <- (i-1)*3       v1 <- vpnt[[bidx+1]]       v2 <- vpnt[[bidx+2]]       v3 <- vpnt[[bidx+3]]       v <- c(v1,v2,v3)       vkey <- paste0(sprintf("%e",v),collapse = ",")       vval <- vhashtab[[vkey]]       mList$nrmList <- c(mList$nrmList,normalize(vval$norm))     }     vnrm <- unlist(mList$nrmList)   }   nvsv <- 3*nv - np   print(sprintf("   tmesh3d - nv:%d np:%d ni:%d maxi:%d mini:%d - vsaved:%d",nv,np,ni,max(vidx),min(vidx),nvsv))   if (donorms) {     part <- tmesh3d(vpnt,vidx,homogeneous=F, normals=vnrm)   } else {     part <- tmesh3d(vpnt,vidx,homogeneous=F)   }   part <- translate3d(rotate3d(part,matrix = rot),trn[[1]],trn[[2]],trn[[3]])   # Center and orient the drone - determined these from the data   # Drone was upside down and facing the wrong way   # making the center to be the center of the pcb board   #   pcbcen <- -0.5*c(54.09200, 71.18820, 75.60720)   part <- translate3d(part,pcbcen[[1]],pcbcen[[2]],pcbcen[[3]])   part <- rotate3d(part,pi,0,1,0 ) # rotate 180 around the y-axis   calccog <- T   if (calccog) {     vb <- part$vb     nvb <- length(vb)     bsq <- (1:(nvb/4) - 1)*4     xc <- vb[bsq + 1]     yc <- vb[bsq + 2]     zc <- vb[bsq + 3]     wc <- vb[bsq + 4]     cx <- mean(min(xc) + max(xc))     cy <- mean(min(yc) + max(yc))     cz <- mean(min(zc) + max(zc))     cw <- mean(min(wc) + max(wc))     tx <- max(xc) - min(xc)     ty <- max(yc) - min(yc)     tz <- max(zc) - min(zc)     tw <- max(wc) - min(wc)     print(sprintf("   cog:%.5f %.5f %.5f %.5f thickness: %.5f %.5f %.5f %.5f",cx,cy,cz,cw,tx,ty,tz,tw))   }   #rgl.material(color=amb,alpha=alf,specular=spc,shininess=shiny)   #shade3d(part)   shade3d(part,color = amb,specular=spc,emissive=ems,alpha = alf,shiny = shiny)   comp$out_vp <- part$vb   comp$out_vi <- part$it   stats <- findBBox(comp$out_vp,compname)   comp$out_vp <- translatePointsFromMatrix(comp$out_vp, -stats$cenv )   comp$out_sca <- c(1,1,1)   # I don't know why this transformation of rot is necessary, but it is..   # m1 swaps Y&Z and then inverts all the axes   #   m1 <- matrix(c(-1,0,0,0,0,-1,0,-1,0),3,3)   comp$out_rot <- m1 %*% rot   comp$out_trn <- stats$cenv   stats <- findBBox(comp$out_vp,compname)   #comp$out_trn <- c(0,0,0)   return(comp) } addAxes <- function(len = 1) {   u <- c(0,1)*len   v <- c(0,0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u,v,w,c("","X"),color=c("red"))   lines3d(w,u,v,color=c("green"))   text3d(w,u,v,c("","Y"),color=c("green"))   lines3d(v,w,u,color=c("blue"))   text3d(v,w,u,c("","Z"),color=c("blue")) } colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } plotWholeThing <- function(partAttList,partVertList,compList) {   for (cp in compList) {     compname <- cp$compname     partname <- gsub("\\-\\d$","",compname)     print(sprintf("Comp:%s part:%s",compname,partname))     rot <- cp$rot     trn <- cp$trn     prta <- partAttList[[partname]]     amb <- colVekToStringColor(prta$ambient)     dif <- colVekToStringColor(prta$diffuse)     spc <- colVekToStringColor(prta$specular)     ems <- colVekToStringColor(prta$emissive)     alf <- prta$ambient[4]     shn <- prta$shinyness     #print(prta$ambient)     vtl <- partVertList[[partname]]     newcp <- plotPartAsMesh(compname,partname,vtl,cp,trn,rot,amb,dif,spc,ems,alf,shn,hashemup = T)     newcp$partid <- prta$id     compList[[compname]] <- newcp   }   addAxes(len = 50)   axes3d()   return(compList) } readCompositionFromXml <- function(stldir,xfname) {   compList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- gsub("\\-\\d$","",compname)     cp <- list()     cp$compname <- compname     cp$partname <- needpart     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       cp$rot <- round(rot,4)       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000.0*as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       cp$trn <- trn       cp$id <- 100*(length(compList)+1)       compList[[compname]] <- cp     }   }   return(compList) } readMaterialsFromXml <- function(stldir,xfname) {   partAttList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     partname <- xml_attr(it,"name")     prt <- list()     prt$partname <- partname     if (!is.null(prt)) {       print(sprintf("Part:%s",partname))       nod <- xml_find_first(it,".//*[local-name()='Ambient']")       prt$ambient <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Diffuse']")       prt$diffuse <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Specular']")       prt$specular <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Emissive']")       prt$emissive <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Shininess']")       prt$shinyness <- as.numeric(xml_text(nod))       print(sprintf("   amb - %.3f",prt$ambient))       print(sprintf("   dif - %.3f",prt$diffuse))       print(sprintf("   spc - %.3f",prt$specular))       print(sprintf("   emi - %.3f",prt$emissive))       print(sprintf("   shn - %.3f",prt$shinyness))       prt$id <- 100*(length(partAttList)+1)       partAttList[[partname]] <- prt     }   }   return(partAttList) } dumpCompList <- function(compList) {   for (cp in compList) {     print(sprintf("%s - %s",cp$compname,cp$partname))     print(cp$rot)     print(cp$trn)   } } findBBox <- function(ptmat,printword = "test",print = T) {   minx <- miny <- minz <- +9e99   maxx <- maxy <- maxz <- -9e99   for (i in 1:dim(ptmat)[2]) {     minx <- min(minx,ptmat[[1,i]])     maxx <- max(maxx,ptmat[[1,i]])     miny <- min(miny,ptmat[[2,i]])     maxy <- max(maxy,ptmat[[2,i]])     minz <- min(minz,ptmat[[3,i]])     maxz <- max(maxz,ptmat[[3,i]])   }   stats <- list()   minv <- c(minx,miny,minz)   maxv <- c(maxx,maxy,maxz)   cenv <- (maxv+minv)/2   stats$minv <- minv   stats$maxv <- maxv   stats$cenv <- cenv   print(sprintf("%s bbox x: %.1f to %.1f    y: %.1f to %.1f    z: %.1f to %.1f",                   printword,minx,maxx,miny,maxy,minz,maxz))   print(sprintf("%s cenv %.1f %.1f %.1f",printword,cenv[1],cenv[2],cenv[3]))   return(stats) } translatePointsFromMatrix <- function(ptmat,trn) {   print(sprintf("Translating trn %.1f %.1f %.1f",trn[1],trn[2],trn[3]))   for (i in 1:dim(ptmat)[2]) {     ptmat[1,i] <- ptmat[1,i] + trn[1]     ptmat[2,i] <- ptmat[2,i] + trn[2]     ptmat[3,i] <- ptmat[3,i] + trn[3]   }   return(ptmat) } fixupname <- function(oname) {   name <- oname   name <- gsub("motor mount-1","motor mount-1",name)   name <- gsub("motor mount-3","motor mount-2",name)   name <- gsub("motor mount-4","motor mount-3",name)   name <- gsub("motor mount-5","motor mount-4",name)   name <- gsub("motor-1","motor---2",name)   name <- gsub("motor-3","motor---1",name)   name <- gsub("motor-2","motor---4",name)   name <- gsub("motor-4","motor---3",name)   name <- gsub("---","-",name)   return(name) } writeOutFiles <- function(fnameroot = "crazyflie",partAttList,partVertList,compList) {   # Components   cdf <- NULL   for (c in compList) {     vs <- round(c$out_sca,5)     vt <- round(c$out_trn,5)     mr <- round(c$out_rot,5)     if (c$id == 1500) {       # pcb not behaving like the rest. No idea why.       mr <- matrix(c(1,0,0,0,1,0,0,0,1),3,3)     }     if (str_detect(line,"propeller")) {        layers <- "cf//base"     } else {       layers <- "cf//staticprop"     }     fixcompname <- fixupname(c$compname)     c1df <- data.frame(id = c$id,compname = fixcompname,                        partid = c$partid,partname = c$partname,                        layers=layers,                        sca.x = vs[1],sca.y = vs[2],sca.z = vs[3],                        trn.x = vt[1],trn.y = vt[2],trn.z = vt[3],                        rot.11 = mr[1,1],rot.12 = mr[1,2],rot.13 = mr[1,3],                        rot.21 = mr[2,1],rot.22 = mr[2,2],rot.23 = mr[2,3],                        rot.31 = mr[3,1],rot.32 = mr[3,2],rot.33 = mr[3,3]                        )     cdf <- rbind(cdf,c1df)   }   cdf <- cdf[order(as.character(cdf$compname)),]   fname <- sprintf("%s-components.csv",fnameroot)   write.csv(cdf,fname,row.names = F)   # Parts   pdf <- NULL   for (p in partAttList) {     p1df <- data.frame(partid = p$id,partname=p$partname,       amb.r = p$ambient[[1]],amb.g = p$ambient[[2]],amb.b = p$ambient[[3]],amb.a = p$ambient[[4]],       dif.r = p$diffuse[[1]],dif.g = p$diffuse[[2]],dif.b = p$diffuse[[3]],dif.a = p$diffuse[[4]],       spc.r = p$specular[[1]],spc.g = p$specular[[2]],spc.b = p$specular[[3]],spc.a = p$specular[[4]],       ems.r = p$emissive[[1]],ems.g = p$emissive[[2]],ems.b = p$emissive[[3]],ems.a = p$emissive[[4]],       shinyness=p$shinyness       )     pdf <- rbind(pdf,p1df)   }   fname <- sprintf("%s-parts.csv",fnameroot)   write.csv(pdf,fname,row.names = F)   # Points   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(round(c$out_vp,5)))     names(pt1df) <- c("x","y","z","w")     pt1df$partid <- c$partid     # only interested in writing the first component for every part     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {        ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-points.csv",fnameroot)   write.csv(ptdf,fname,row.names = F)   # VertsIdx   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(c$out_vi))     names(pt1df) <- c("v1","v2","v3")     #pt1df$id <- c$id     pt1df$partid <- c$partid     # only write out the first ones     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {       ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-vertidx.csv",fnameroot)   write.csv(ptdf,fname,row.names = F) } # Start of actual program # ======================= starttime <- Sys.time() stldir <- "../Crazyflie-CAD/STL" # Get the STL files with the vertices and read them in stlfiles <- list.files(stldir,"\\.STL$") partVertList <- list() for (fname in stlfiles) {   partVertList <- readVertsFromStl(stldir,fname,partVertList) } # Now read the composistion file which has the part instances,  #  their transformations which position them, and their material properties #  compList <- readCompositionFromXml(stldir,"Crazyflie_assembly.xml") compList <- compList[order(sapply(compList,'[[',"compname"))]  # order them partAttList <- readMaterialsFromXml(stldir,"Crazyflie_assembly.xml") partAttList <- partAttList[order(sapply(partAttList,'[[',"partname"))] # order them compList <- plotWholeThing(partAttList,partVertList,compList) writeOutFiles("crazyflie",partAttList,partVertList,compList) elap <- as.numeric((Sys.time() - starttime)[1], units = "secs") print(sprintf("Run took %.1f secs for %d verts - verts optimized away:%d", elap,nvtot,nvsaved))
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to plot CAD model of CrazyFlie mini-drone # #  It performs the following septs #   1. read in STL files from local copy of github repository Crazyflie-CAD #   2. create optimized triangle meshes out of it (optimized in reducing the number of points) #   3. orienting the data so it has the right x,y,z orientation #   4. ploting in in rgl #   5. writing out the data in a small set of csv files #   appendListAsSubEl <- function(vlist,v) {   # Append a list to a list as a sub-element    # i.e. do not merge the lists (thus losing structure)   # and retain the top list's attributes    if (!is.null(v)) {     vlist[[length(vlist) + 1]] <- v     # Note, if we use the faster method below, we loose the attributes of vlist!     # Bad, bad, bad...     # vlist <- c(vlist,v)   }   return(vlist) } extractVert <- function(line) {   rv <- c(0,0,0)   sar <- str_split(line,"[\\s]")[[1]] # only one element in line   n <- length(sar)   if (n >= 3) {     rv <- c(as.numeric(sar[[n-2]]),as.numeric(sar[[n-1]]),as.numeric(sar[[n]]))   }   return(rv) } readVertsFromStl <- function(stldir, stlfname,vertPartList) {   starttime <- Sys.time()   if (!is.null(stldir) & stldir!="") {     stlfname <- sprintf("%s/%s", stldir, stlfname)   }   lines <- readLines(stlfname, warn = F)   nlines0 <- length(lines)   if (nlines0 < 6) {     print(sprintf("File too short:%d", length(nlines0)))     return(NULL)   }   print(sprintf("Read %d lines from %s",nlines0,stlfname))   vertPtList <- list()   # extract the first line which is the name of the part   partname <- lines[[1]]   partname <- gsub("solid ","",partname)   partname <- gsub("_Default_sldprt","",partname)   lines <- lines[2:length(lines)]   # trim out stuff we do not need   lines <- lines[!str_detect(lines,"outer loop")]   lines <- lines[!str_detect(lines,"endloop")]   lines <- lines[!str_detect(lines,"endfacet")]   lines <- lines[!str_detect(lines, "endsolid")]   print(sprintf("Stripped out %d irrelevant lines", nlines0-length(lines)))   # now loop over what is left and accumulate the facet vector   facetvek <- list()   for (line in lines) {     if (str_detect(line, "facet")) {       if (length(facetvek) == 4) {         vertPtList <- appendListAsSubEl(vertPtList,facetvek)       }       facetvek <- list()       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else if (str_detect(line, "vertex")) {       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else {       print(sprintf("opps unknown linetype:%s",line))     }   }   vertPtList <- appendListAsSubEl(vertPtList,facetvek) # add the remaining one tp vertPtList   vertTopList <- list()   vertTopList$vertPtList <- vertPtList   vertTopList$partname <- partname   vertPartList[[partname]] <- vertTopList   elap <- as.numeric((Sys.time() - starttime)[1], units = "secs")   print(sprintf("Extracted %d vertices in %.1f secs for part '%s'", length(vertPtList),elap,partname))   return(vertPartList) } # hash bookkeeping vhashtab <- hash() nvsaved <- 0 nvtot <- 0 addVertHashed <- function(mList,v,n = NULL) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   vkey <- paste0(sprintf("%e",v),collapse=",")   if (has.key(vkey,vhashtab)) {     vval <- vhashtab[[vkey]]     #print(sprintf("np:%d ni:%d vkey:%s nval:%d",np,ni,vkey,nval))     mList$idxList <- c(mList$idxList,vval$vnum)     if (!is.null(n)) {       vval$norm <- vval$norm + n     }     nvsaved <<- nvsaved+1   } else {     vnum <- (np + 3) / 3     vval <- list()     vval$vnum <- vnum     if (!is.null(n)) vval$norm <- n     vhashtab[vkey] <- vval     mList$pntList <- c(mList$pntList,v[1],v[2],v[3])     mList$idxList <- c(mList$idxList,vnum)     nvtot <<- nvtot+1   }   return(mList) } addVert <- function(mList,v,n = NULL) {   # no hashing   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList <- c(mList$pntList, v[1],v[2],v[3])   mList$idxList <- c(mList$idxList, ni+1)   nvtot <<- nvtot+1   return(mList) } addTri <- function(mList,v1,v2,v3,norm,hashemup=T) {   if (hashemup) {     mList <- addVertHashed(mList,v1,norm)     mList <- addVertHashed(mList,v2,norm)     mList <- addVertHashed(mList,v3,norm)   } else {     mList <- addVert(mList,v1,norm)     mList <- addVert(mList,v2,norm)     mList <- addVert(mList,v3,norm)   }   return(mList) } normalize <- function(n) {   vlen <- sqrt(n[[1]]^2 + n[[2]]^2 + n[[3]]^2)   if (vlen>0) {     n <- n/vlen   }   return(n) } plotPartAsMesh <- function(compname,partname,vertTopList,comp,trn = c(0,0,0),rot = NULL,                            amb = "silver",dif=NULL,spc=NULL,ems=NULL,alf = 1,shiny = 50,donorms = F,hashemup = T) {   vhashtab <<- hash()   vertPtList <- vertTopList$vertPtList   mList <- list()   mList$idxList <- list()   mList$pntList <- list()   mList$nrmList <- list()   normval <- NULL   for (v in vertPtList) {     if (length(v) == 4) {       if (donorms) normval <- v[[1]]       mList <- addTri(mList,v[[2]],v[[3]],v[[4]],normval,hashemup=hashemup)      }   }   vidx <- unlist(mList$idxList)   vpnt <- unlist(mList$pntList)   nv <- length(vertPtList)   ni <- length(vidx)   np <- length(vpnt)   # Not sure I can make donorms work right   # giving up for now - 2016.12.1   #   if (donorms) {     nn <- np / 3     for (i in 1:nn) {       bidx <- (i-1)*3       v1 <- vpnt[[bidx+1]]       v2 <- vpnt[[bidx+2]]       v3 <- vpnt[[bidx+3]]       v <- c(v1,v2,v3)       vkey <- paste0(sprintf("%e",v),collapse = ",")       vval <- vhashtab[[vkey]]       mList$nrmList <- c(mList$nrmList,normalize(vval$norm))     }     vnrm <- unlist(mList$nrmList)   }   nvsv <- 3*nv - np   print(sprintf("   tmesh3d - nv:%d np:%d ni:%d maxi:%d mini:%d - vsaved:%d",nv,np,ni,max(vidx),min(vidx),nvsv))   if (donorms) {     part <- tmesh3d(vpnt,vidx,homogeneous=F, normals=vnrm)   } else {     part <- tmesh3d(vpnt,vidx,homogeneous=F)   }   part <- translate3d(rotate3d(part,matrix = rot),trn[[1]],trn[[2]],trn[[3]])   # Center and orient the drone - determined these from the data   # Drone was upside down and facing the wrong way   # making the center to be the center of the pcb board   #   pcbcen <- -0.5*c(54.09200, 71.18820, 75.60720)   part <- translate3d(part,pcbcen[[1]],pcbcen[[2]],pcbcen[[3]])   part <- rotate3d(part,pi,0,1,0 ) # rotate 180 around the y-axis   calccog <- T   if (calccog) {     vb <- part$vb     nvb <- length(vb)     bsq <- (1:(nvb/4) - 1)*4     xc <- vb[bsq + 1]     yc <- vb[bsq + 2]     zc <- vb[bsq + 3]     wc <- vb[bsq + 4]     cx <- mean(min(xc) + max(xc))     cy <- mean(min(yc) + max(yc))     cz <- mean(min(zc) + max(zc))     cw <- mean(min(wc) + max(wc))     tx <- max(xc) - min(xc)     ty <- max(yc) - min(yc)     tz <- max(zc) - min(zc)     tw <- max(wc) - min(wc)     print(sprintf("   cog:%.5f %.5f %.5f %.5f thickness: %.5f %.5f %.5f %.5f",cx,cy,cz,cw,tx,ty,tz,tw))   }   #rgl.material(color=amb,alpha=alf,specular=spc,shininess=shiny)   #shade3d(part)   shade3d(part,color = amb,specular=spc,emissive=ems,alpha = alf,shiny = shiny)   comp$out_vp <- part$vb   comp$out_vi <- part$it   stats <- findBBox(comp$out_vp,compname)   comp$out_vp <- translatePointsFromMatrix(comp$out_vp, -stats$cenv )   comp$out_sca <- c(1,1,1)   # I don't know why this transformation of rot is necessary, but it is..   # m1 swaps Y&Z and then inverts all the axes   #   m1 <- matrix(c(-1,0,0,0,0,-1,0,-1,0),3,3)   comp$out_rot <- m1 %*% rot   comp$out_trn <- stats$cenv   stats <- findBBox(comp$out_vp,compname)   #comp$out_trn <- c(0,0,0)   return(comp) } addAxes <- function(len = 1) {   u <- c(0,1)*len   v <- c(0,0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u,v,w,c("","X"),color=c("red"))   lines3d(w,u,v,color=c("green"))   text3d(w,u,v,c("","Y"),color=c("green"))   lines3d(v,w,u,color=c("blue"))   text3d(v,w,u,c("","Z"),color=c("blue")) } colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } plotWholeThing <- function(partAttList,partVertList,compList) {   for (cp in compList) {     compname <- cp$compname     partname <- gsub("\\-\\d$","",compname)     print(sprintf("Comp:%s part:%s",compname,partname))     rot <- cp$rot     trn <- cp$trn     prta <- partAttList[[partname]]     amb <- colVekToStringColor(prta$ambient)     dif <- colVekToStringColor(prta$diffuse)     spc <- colVekToStringColor(prta$specular)     ems <- colVekToStringColor(prta$emissive)     alf <- prta$ambient[4]     shn <- prta$shinyness     #print(prta$ambient)     vtl <- partVertList[[partname]]     newcp <- plotPartAsMesh(compname,partname,vtl,cp,trn,rot,amb,dif,spc,ems,alf,shn,hashemup = T)     newcp$partid <- prta$id     compList[[compname]] <- newcp   }   addAxes(len = 50)   axes3d()   return(compList) } readCompositionFromXml <- function(stldir,xfname) {   compList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- gsub("\\-\\d$","",compname)     cp <- list()     cp$compname <- compname     cp$partname <- needpart     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       cp$rot <- round(rot,4)       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000.0*as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       cp$trn <- trn       cp$id <- 100*(length(compList)+1)       compList[[compname]] <- cp     }   }   return(compList) } readMaterialsFromXml <- function(stldir,xfname) {   partAttList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     partname <- xml_attr(it,"name")     prt <- list()     prt$partname <- partname     if (!is.null(prt)) {       print(sprintf("Part:%s",partname))       nod <- xml_find_first(it,".//*[local-name()='Ambient']")       prt$ambient <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Diffuse']")       prt$diffuse <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Specular']")       prt$specular <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Emissive']")       prt$emissive <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Shininess']")       prt$shinyness <- as.numeric(xml_text(nod))       print(sprintf("   amb - %.3f",prt$ambient))       print(sprintf("   dif - %.3f",prt$diffuse))       print(sprintf("   spc - %.3f",prt$specular))       print(sprintf("   emi - %.3f",prt$emissive))       print(sprintf("   shn - %.3f",prt$shinyness))       prt$id <- 100*(length(partAttList)+1)       partAttList[[partname]] <- prt     }   }   return(partAttList) } dumpCompList <- function(compList) {   for (cp in compList) {     print(sprintf("%s - %s",cp$compname,cp$partname))     print(cp$rot)     print(cp$trn)   } } findBBox <- function(ptmat,printword = "test",print = T) {   minx <- miny <- minz <- +9e99   maxx <- maxy <- maxz <- -9e99   for (i in 1:dim(ptmat)[2]) {     minx <- min(minx,ptmat[[1,i]])     maxx <- max(maxx,ptmat[[1,i]])     miny <- min(miny,ptmat[[2,i]])     maxy <- max(maxy,ptmat[[2,i]])     minz <- min(minz,ptmat[[3,i]])     maxz <- max(maxz,ptmat[[3,i]])   }   stats <- list()   minv <- c(minx,miny,minz)   maxv <- c(maxx,maxy,maxz)   cenv <- (maxv+minv)/2   stats$minv <- minv   stats$maxv <- maxv   stats$cenv <- cenv   print(sprintf("%s bbox x: %.1f to %.1f    y: %.1f to %.1f    z: %.1f to %.1f",                   printword,minx,maxx,miny,maxy,minz,maxz))   print(sprintf("%s cenv %.1f %.1f %.1f",printword,cenv[1],cenv[2],cenv[3]))   return(stats) } translatePointsFromMatrix <- function(ptmat,trn) {   print(sprintf("Translating trn %.1f %.1f %.1f",trn[1],trn[2],trn[3]))   for (i in 1:dim(ptmat)[2]) {     ptmat[1,i] <- ptmat[1,i] + trn[1]     ptmat[2,i] <- ptmat[2,i] + trn[2]     ptmat[3,i] <- ptmat[3,i] + trn[3]   }   return(ptmat) } fixupname <- function(oname) {   name <- oname   name <- gsub("motor mount-1","motor mount-1",name)   name <- gsub("motor mount-3","motor mount-2",name)   name <- gsub("motor mount-4","motor mount-3",name)   name <- gsub("motor mount-5","motor mount-4",name)   name <- gsub("motor-1","motor---2",name)   name <- gsub("motor-3","motor---1",name)   name <- gsub("motor-2","motor---4",name)   name <- gsub("motor-4","motor---3",name)   name <- gsub("---","-",name)   return(name) } writeOutFiles <- function(fnameroot = "crazyflie",partAttList,partVertList,compList) {   # Components   cdf <- NULL   for (c in compList) {     vs <- round(c$out_sca,5)     vt <- round(c$out_trn,5)     mr <- round(c$out_rot,5)     if (c$id == 1500) {       # pcb not behaving like the rest. No idea why.       mr <- matrix(c(1,0,0,0,1,0,0,0,1),3,3)     }     if (str_detect(c$compname,"propeller")) {        layers <- "cf//base"     } else {       layers <- "cf//staticprop"     }     fixcompname <- fixupname(c$compname)     c1df <- data.frame(id = c$id,compname = fixcompname,                        partid = c$partid,partname = c$partname,                        layers=layers,                        sca.x = vs[1],sca.y = vs[2],sca.z = vs[3],                        trn.x = vt[1],trn.y = vt[2],trn.z = vt[3],                        rot.11 = mr[1,1],rot.12 = mr[1,2],rot.13 = mr[1,3],                        rot.21 = mr[2,1],rot.22 = mr[2,2],rot.23 = mr[2,3],                        rot.31 = mr[3,1],rot.32 = mr[3,2],rot.33 = mr[3,3]                        )     cdf <- rbind(cdf,c1df)   }   cdf <- cdf[order(as.character(cdf$compname)),]   fname <- sprintf("%s-components.csv",fnameroot)   write.csv(cdf,fname,row.names = F)   # Parts   pdf <- NULL   for (p in partAttList) {     p1df <- data.frame(partid = p$id,partname=p$partname,       amb.r = p$ambient[[1]],amb.g = p$ambient[[2]],amb.b = p$ambient[[3]],amb.a = p$ambient[[4]],       dif.r = p$diffuse[[1]],dif.g = p$diffuse[[2]],dif.b = p$diffuse[[3]],dif.a = p$diffuse[[4]],       spc.r = p$specular[[1]],spc.g = p$specular[[2]],spc.b = p$specular[[3]],spc.a = p$specular[[4]],       ems.r = p$emissive[[1]],ems.g = p$emissive[[2]],ems.b = p$emissive[[3]],ems.a = p$emissive[[4]],       shinyness=p$shinyness       )     pdf <- rbind(pdf,p1df)   }   fname <- sprintf("%s-parts.csv",fnameroot)   write.csv(pdf,fname,row.names = F)   # Points   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(round(c$out_vp,5)))     names(pt1df) <- c("x","y","z","w")     pt1df$partid <- c$partid     # only interested in writing the first component for every part     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {        ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-points.csv",fnameroot)   write.csv(ptdf,fname,row.names = F)   # VertsIdx   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(c$out_vi))     names(pt1df) <- c("v1","v2","v3")     #pt1df$id <- c$id     pt1df$partid <- c$partid     # only write out the first ones     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {       ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-vertidx.csv",fnameroot)   write.csv(ptdf,fname,row.names = F) } # Start of actual program # ======================= starttime <- Sys.time() stldir <- "../Crazyflie-CAD/STL" # Get the STL files with the vertices and read them in stlfiles <- list.files(stldir,"\\.STL$") partVertList <- list() for (fname in stlfiles) {   partVertList <- readVertsFromStl(stldir,fname,partVertList) } # Now read the composistion file which has the part instances,  #  their transformations which position them, and their material properties #  compList <- readCompositionFromXml(stldir,"Crazyflie_assembly.xml") compList <- compList[order(sapply(compList,'[[',"compname"))]  # order them partAttList <- readMaterialsFromXml(stldir,"Crazyflie_assembly.xml") partAttList <- partAttList[order(sapply(partAttList,'[[',"partname"))] # order them compList <- plotWholeThing(partAttList,partVertList,compList) writeOutFiles("crazyflie",partAttList,partVertList,compList) elap <- as.numeric((Sys.time() - starttime)[1], units = "secs") print(sprintf("Run took %.1f secs for %d verts - verts optimized away:%d", elap,nvtot,nvsaved))
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
max(1,2,3)
max(1,2,3,4)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("D:/local/rgl4crazyflie/rgl4crazyflie.R", encoding = "Windows-1252")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
head(vpnt)
length(vpnt)
rot
nv <- len(vpnt)/3
nv <- length(vpnt)/3
vpntm <- matrix(vpnt,nv,3)
head(vpntm)
rp <- vpntm %*% rot
head(rp)
trn <- c(0,1,2)
rp1t <- rp + trn
head(rp1t)
zrp <- matrix(0,nv,3)
zrp1t <- zrp + trn
head(zrp1t)
zrp <- matrix(0,nv,3)
t(trn)
zrp1t <- zrp + t(trn)
zrp <- matrix(0,nv,3)
zrp[,1] <- zrp[,1] + trn[1]
head(zrp)
zrp[,2] <- zrp[,2] + trn[2]
head(zrp)
zrp[,3] <- zrp[,3] + trn[3]
head(zrp)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
pcbcen <- -0.5 * c(54.09200,71.18820,75.60720)
c(10,10,10) + pcbcen
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id>0,]   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b) pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b) pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b) pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b) getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
x <- c(1,2,3)
y <- c(4,5,6)
z <- c(7,8,9)
v <- sapply(1:3,function (x) c(x[i],y[i],z[i]))
v <- sapply(1:3,function (y) c(x[i],y[i],z[i]))
v <- sapply(1:3,function (i) c(x[i],y[i],z[i]))
v
df <- data.frame(x=c(1,2,3),y=c(4,5,6))
df$trn <- sapply(1:nrow(df),function (i) c(df$x[i],df$y[i]))
df$trn <- lapply(1:nrow(df),function (i) c(df$x[i],df$y[i]))
df$trn
class(df[[1]])
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   mesh <- scale3d(mesh,x=cdf$sca[1],y=cdf$sca[2],z=cdf$sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,cdf$trn[1],cdf$trn[2],cdf$trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[cidx]   trn <- cdf$sca[cidx]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   #sca <- cdf$sca[cidx]   #trn <- cdf$trn[cidx]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("D:/local/rgl4crazyflie/readcf.R", encoding = "Windows-1252")
cdf$sca[1]
cdf$sca[[1]]
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } r <- readMesh("crazyflie") open3d() addAxes <- function(len = 1,t=c(0,0,0),r=NULL,tit="") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u+t[1],v+t[2],w+t[3],          color = c("red"))   text3d( u+t[1],v+t[2],w+t[3],c("","X"),color = c("red"),cex=1)   lines3d(w+t[1],u+t[2],v+t[3],          color = c("green"))   text3d( w+t[1],u+t[2],v+t[3],c("","Y"),color = c("green"))   lines3d(v+t[1],w+t[2],u+t[3],          color = c("blue"))   text3d( v+t[1],w+t[2],u+t[3],c("","Z"),color = c("blue")) } cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {    m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3)# matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf) #  cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i])) #  cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)  # sca <- cdf$sca[[cidx]]  # trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf) #  cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i])) #  cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)  # sca <- cdf$sca[[cidx]]  # trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   m <- matrix(c(rvek,gvek,bvek),nrow(pdf),3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf) #  cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i])) #  cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)  # sca <- cdf$sca[[cidx]]  # trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
rtvs::debug_source("D:/local/rgl4crazyflie/readcf.R", encoding = "Windows-1252")
rtvs::debug_source("D:/local/rgl4crazyflie/readcf.R", encoding = "Windows-1252")
matrix(c(rvek,gvek,bvek),nrow(pdf),3)
nrow(pdf)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf) #  cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i])) #  cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)  # sca <- cdf$sca[[cidx]]  # trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   cdf$rot <- lapply(1:nc,function(i) matrix(c( cdf$rot.11[i],cdf$rot.12[i],cdf$rot.13[i],                                                cdf$rot.21[i],cdf$rot.22[i],cdf$rot.23[i],                                                cdf$rot.31[i],cdf$rot.32[i],cdf$rot.33[i]),3,3)   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } getRot <- function(cdf,cidx) {   rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   if (sum(abs(rot)) == 0) {     return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   } else {     return(rot)   } } getTrn <- function(cdf,cidx) {   trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   return(trn) } getSca <- function(cdf,cidx) {   sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   return(sca) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   cdf$rot <- lapply(1:nc,function(i) matrix(c( cdf$rot.11[i],cdf$rot.12[i],cdf$rot.13[i],                                                cdf$rot.21[i],cdf$rot.22[i],cdf$rot.23[i],                                                cdf$rot.31[i],cdf$rot.32[i],cdf$rot.33[i]),3,3))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   sca <- getSca(cdf,cidx)   rot <- getRot(cdf,cidx)   trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } #getRot <- function(cdf,cidx) {   #rot <- matrix(c(cdf$rot.11[cidx],cdf$rot.12[cidx],cdf$rot.13[cidx],                   #cdf$rot.21[cidx],cdf$rot.22[cidx],cdf$rot.23[cidx],                   #cdf$rot.31[cidx],cdf$rot.32[cidx],cdf$rot.33[cidx]),3,3)   #if (sum(abs(rot)) == 0) {     #return(matrix(c(1,0,0,0,1,0,0,0,1),3,3))   #} else {     #return(rot)   #} #} #getTrn <- function(cdf,cidx) {   #trn <- c(cdf$trn.x[cidx],cdf$trn.y[cidx],cdf$trn.z[cidx])   #return(trn) #} #getSca <- function(cdf,cidx) {   #sca <- c(cdf$sca.x[cidx],cdf$sca.y[cidx],cdf$sca.z[cidx])   #return(sca) #} readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   cdf$rot <- lapply(1:nc,function(i) matrix(c( cdf$rot.11[i],cdf$rot.12[i],cdf$rot.13[i],                                                cdf$rot.21[i],cdf$rot.22[i],cdf$rot.23[i],                                                cdf$rot.31[i],cdf$rot.32[i],cdf$rot.33[i]),3,3))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } r <- readMesh("crazyflie") open3d() cdf <- r$cdf pdf <- r$pdf ptdf <- r$ptdf vidf <- r$vidf ncomp <- nrow(r$cdf) npart <- nrow(r$pdf) for (cidx in 1:ncomp) {   # setup   cid <- cdf$id[cidx]   cname <- cdf$compname[cidx]   pname <- cdf$partname[cidx]   pidx <- which(pdf$partname == pname)   partid <- pdf$partid[pidx]   # now find the first component that has the same partname as this component   # we are experimenting with changing out for parts   # get the points for this component   pt1df <- ptdf[ptdf$partid == partid,]   pt1df$partid <- NULL   mpt <- t(as.matrix(pt1df))   # get the indexs for this component   vi1df <- vidf[vidf$partid == partid,]   vi1df$partid <- NULL   mvi <- t(as.matrix(vi1df))   # make the mesh, then rotate and transform if necssary   mesh <- tmesh3d(mpt,mvi)   #sca <- getSca(cdf,cidx)   #rot <- getRot(cdf,cidx)   #trn <- getTrn(cdf,cidx)   sca <- cdf$sca[[cidx]]   rot <- cdf$rot[[cidx]]   trn <- cdf$trn[[cidx]]   mesh <- scale3d(mesh,x=sca[1],y=sca[2],z=sca[3] )   mesh <- rotate3d(mesh,matrix = rot)   mesh <- translate3d(mesh,trn[1],trn[2],trn[3])   # render it   print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))   clr <- pdf$amb[pidx]   # mounts and motor part numbers    #   1 1600 500   #   2 1100 300   #   3 100 600   #   4 200 400   shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])   addAxes(10,t = trn,r = rot) # show the local coordinate system } addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   cdf$rot <- lapply(1:nc,function(i) matrix(c( cdf$rot.11[i],cdf$rot.12[i],cdf$rot.13[i],                                                cdf$rot.21[i],cdf$rot.22[i],cdf$rot.23[i],                                                cdf$rot.31[i],cdf$rot.32[i],cdf$rot.33[i]),3,3))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } plotMesh <- function(obj) {   cdf <- obj$cdf   pdf <- obj$pdf   ptdf <- obj$ptdf   vidf <- obj$vidf   ncomp <- nrow(obj$cdf)   npart <- nrow(obj$pdf)   for (cidx in 1:ncomp) {     # setup     cid <- cdf$id[cidx]     cname <- cdf$compname[cidx]     pname <- cdf$partname[cidx]     pidx <- which(pdf$partname == pname)     partid <- pdf$partid[pidx]     # get the points for this component     pt1df <- ptdf[ptdf$partid == partid,]     pt1df$partid <- NULL     mpt <- t(as.matrix(pt1df))     # get the indexs for this component     vi1df <- vidf[vidf$partid == partid,]     vi1df$partid <- NULL     mvi <- t(as.matrix(vi1df))     # make the mesh, then rotate and transform if necssary     mesh <- tmesh3d(mpt,mvi)     sca <- cdf$sca[[cidx]]     rot <- cdf$rot[[cidx]]     trn <- cdf$trn[[cidx]]     mesh <- scale3d(mesh,x = sca[1],y = sca[2],z = sca[3])     mesh <- rotate3d(mesh,matrix = rot)     mesh <- translate3d(mesh,trn[1],trn[2],trn[3])     # render it     print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))     clr <- pdf$amb[pidx]     # mounts and motor part id numbers      #   1 1600 500     #   2 1100 300     #   3 100 600     #   4 200 400     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } open3d() robv <- readMesh("crazyflie") plotMesh(robv) addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to plot CAD model of CrazyFlie mini-drone # #  It performs the following septs #   1. read in STL files from local copy of github repository Crazyflie-CAD #   2. create optimized triangle meshes out of it (optimized in reducing the number of points) #   3. orienting the data so it has the right x,y,z orientation #   4. ploting in in rgl #   5. writing out the data in a small set of csv files #   readCzfVertsFromStl <- function(stldir,stlfname,vertPartList) {   appendListAsSubEl <- function(vlist,v) {     # Append a list to a list as a sub-element      # i.e. do not merge the lists (thus losing structure)     # and retain the top list's attributes      if (!is.null(v)) {       vlist[[length(vlist) + 1]] <- v       # Note, if we use the faster method below, we loose the attributes of vlist!       # Bad, bad, bad...       # vlist <- c(vlist,v)     }     return(vlist)   }   extractVert <- function(line) {     rv <- c(0,0,0)     sar <- str_split(line,"[\\s]")[[1]] # only one element in line     n <- length(sar)     if (n >= 3) {       rv <- c(as.numeric(sar[[n - 2]]),as.numeric(sar[[n - 1]]),as.numeric(sar[[n]]))     }     return(rv)   }   starttime <- Sys.time()   if (!is.null(stldir) & stldir != "") {     stlfname <- sprintf("%s/%s",stldir,stlfname)   }   lines <- readLines(stlfname,warn = F)   nlines0 <- length(lines)   if (nlines0 < 6) {     print(sprintf("File too short:%d",length(nlines0)))     return(NULL)   }   print(sprintf("Read %d lines from %s",nlines0,stlfname))   vertPtList <- list()   # extract the first line which is the name of the part   partname <- lines[[1]]   partname <- gsub("solid ","",partname)   partname <- gsub("_Default_sldprt","",partname)   lines <- lines[2:length(lines)]   # trim out stuff we do not need   lines <- lines[!str_detect(lines,"outer loop")]   lines <- lines[!str_detect(lines,"endloop")]   lines <- lines[!str_detect(lines,"endfacet")]   lines <- lines[!str_detect(lines,"endsolid")]   print(sprintf("Stripped out %d irrelevant lines",nlines0 - length(lines)))   # now loop over what is left and accumulate the facet vector   facetvek <- list()   for (line in lines) {     if (str_detect(line,"facet")) {       if (length(facetvek) == 4) {         vertPtList <- appendListAsSubEl(vertPtList,facetvek)       }       facetvek <- list()       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else if (str_detect(line,"vertex")) {       facetvek <- appendListAsSubEl(facetvek,extractVert(line))     } else {       print(sprintf("opps unknown linetype:%s",line))     }   }   vertPtList <- appendListAsSubEl(vertPtList,facetvek) # add the remaining one tp vertPtList   vertTopList <- list()   vertTopList$vertPtList <- vertPtList   vertTopList$partname <- partname   vertPartList[[partname]] <- vertTopList   elap <- as.numeric((Sys.time() - starttime)[1],units = "secs")   print(sprintf("Extracted %d vertices in %.1f secs for part '%s'",length(vertPtList),elap,partname))   return(vertPartList) } # hash bookkeeping vhashtab <- hash() nvsaved <- 0 nvtot <- 0 addVertHashed <- function(mList,v,n = NULL) {   ni <- length(mList$idxList)   np <- length(mList$pntList)   vkey <- paste0(sprintf("%e",v),collapse = ",")   if (has.key(vkey,vhashtab)) {     vval <- vhashtab[[vkey]]     #print(sprintf("np:%d ni:%d vkey:%s nval:%d",np,ni,vkey,nval))     mList$idxList <- c(mList$idxList,vval$vnum)     nvsaved <<- nvsaved + 1   } else {     vnum <- (np + 3) / 3     vval <- list()     vval$vnum <- vnum     vhashtab[vkey] <- vval     mList$pntList <- c(mList$pntList,v[1],v[2],v[3])     mList$idxList <- c(mList$idxList,vnum)     nvtot <<- nvtot + 1   }   return(mList) } addVert <- function(mList,v,n = NULL) {   # no hashing   ni <- length(mList$idxList)   np <- length(mList$pntList)   mList$pntList <- c(mList$pntList,v[1],v[2],v[3])   mList$idxList <- c(mList$idxList,ni + 1)   nvtot <<- nvtot + 1   return(mList) } addTri <- function(mList,v1,v2,v3,hashemup = T) {   if (hashemup) {     mList <- addVertHashed(mList,v1)     mList <- addVertHashed(mList,v2)     mList <- addVertHashed(mList,v3)   } else {     mList <- addVert(mList,v1)     mList <- addVert(mList,v2)     mList <- addVert(mList,v3)   }   return(mList) } normalize <- function(n) {   vlen <- sqrt(n[[1]] ^ 2 + n[[2]] ^ 2 + n[[3]] ^ 2)   if (vlen > 0) {     n <- n / vlen   }   return(n) } findBBox <- function(ptmat,printword = "test",print = T) {   minx <- miny <- minz <- +9e99   maxx <- maxy <- maxz <- -9e99   for (i in 1:dim(ptmat)[2]) {     minx <- min(minx,ptmat[[1,i]])     maxx <- max(maxx,ptmat[[1,i]])     miny <- min(miny,ptmat[[2,i]])     maxy <- max(maxy,ptmat[[2,i]])     minz <- min(minz,ptmat[[3,i]])     maxz <- max(maxz,ptmat[[3,i]])   }   stats <- list()   minv <- c(minx,miny,minz)   maxv <- c(maxx,maxy,maxz)   cenv <- (maxv + minv) / 2   stats$minv <- minv   stats$maxv <- maxv   stats$cenv <- cenv   print(sprintf("%s bbox x: %.1f to %.1f    y: %.1f to %.1f    z: %.1f to %.1f",                   printword,minx,maxx,miny,maxy,minz,maxz))   print(sprintf("%s cenv %.1f %.1f %.1f",printword,cenv[1],cenv[2],cenv[3]))   return(stats) } translatePointsFromMatrix <- function(ptmat,trn) {   print(sprintf("Translating trn %.1f %.1f %.1f",trn[1],trn[2],trn[3]))   for (i in 1:dim(ptmat)[2]) {     ptmat[1,i] <- ptmat[1,i] + trn[1]     ptmat[2,i] <- ptmat[2,i] + trn[2]     ptmat[3,i] <- ptmat[3,i] + trn[3]   }   return(ptmat) } combinePointsIntoMesh <- function(compname = "some_comp",                                   vertPtList,ix = 1,iy = 2,iz = 3,hashemup = T,                                   trn = c(0,0,0),center = T,                                   prerot = matrix(c(1,0,0,0,1,0,0,0,1),3,3),                                   postrot = matrix(c(1,0,0,0,1,0,0,0,1),3,3)) {   #  Takes a list of 3D vectors that representing a triangle   # v1,v2,v3 being the points where the vertices are located   # the ix,iy,iz allow the x,y and z positions to be exchanged   # if hashemup is T, then identiacl points will be merged in the resulting   # vertex list   # Returns a list of indexs (1 based), and a list of points   # no check or correction for backface/frontface consistentcy   # if center=true, then the points are centered on the middle of the   # bounding box and a translation vector is returned   #   vhashtab <<- hash()   mList <- list()   mList$idxList <- list()   mList$pntList <- list()   mList$nrmList <- list()   normval <- NULL   ineed <- max(ix,iy,iz)   for (v in vertPtList) {     if (length(v) >= ineed) {       mList <- addTri(mList,v[[ix]],v[[iy]],v[[iz]],hashemup = hashemup)     }   }   vidx <- unlist(mList$idxList)   vpnt <- unlist(mList$pntList)   vpntm <- t(matrix(vpnt,3,length(vpnt) / 3))   vpntm <- vpntm %*% prerot   vpntm[,1] <- vpntm[,1] + trn[1]   vpntm[,2] <- vpntm[,2] + trn[2]   vpntm[,3] <- vpntm[,3] + trn[3]   vpntm <- vpntm %*% postrot   cen <- c(0,0,0)   if (center) {     stats <- findBBox(comp$out_vp,compname)     cen <- stats$cenv     vpntm[,1] <- vpntm[,1] - cen[1]     vpntm[,2] <- vpntm[,2] - cen[2]     vpntm[,3] <- vpntm[,3] - cen[3]   }   rv <- list()   rv$compname <- compname   rv$vidx <- vidx   rv$vpnt <- as.numeric(t(vpntm))   rv$cen <- cen   return(rv) } calcMeshCog <- function(part) {   vb <- part$vb   nvb <- length(vb)   bsq <- (1:(nvb / 4) - 1) * 4   xc <- vb[bsq + 1]   yc <- vb[bsq + 2]   zc <- vb[bsq + 3]   wc <- vb[bsq + 4]   cx <- mean(min(xc) + max(xc))   cy <- mean(min(yc) + max(yc))   cz <- mean(min(zc) + max(zc))   cw <- mean(min(wc) + max(wc))   tx <- max(xc) - min(xc)   ty <- max(yc) - min(yc)   tz <- max(zc) - min(zc)   tw <- max(wc) - min(wc)   print(sprintf("   cog:%.5f %.5f %.5f %.5f thickness: %.5f %.5f %.5f %.5f",cx,cy,cz,cw,tx,ty,tz,tw)) } plotPartAsMesh <- function(compname,partname,vertTopList,comp,trn = c(0,0,0),rot = NULL,                            amb = "silver",dif = NULL,spc = NULL,ems = NULL,alf = 1,shiny = 50,hashemup = T,quiet = F) {   # we want it to be centerd on the center of the pcb (which id probably a bit under its cog, but close enough..   pcbcen <- -0.5 * c(54.09200,71.18820,75.60720)   reorient <- matrix(c(-1,0,0,0,1,0,0,0,-1),3,3)   ident <- matrix(c(1,0,0,0,1,0,0,0,1),3,3)   rv <- combinePointsIntoMesh(compname,vertTopList$vertPtList,2,3,4,prerot=rot,trn=(trn+pcbcen),postrot=ident,center=F)   nv <- length(vertTopList$vertPtList)   vidx <- rv$vidx   vpnt <- rv$vpnt   ni <- length(vidx)   np <- length(vpnt)   nvsv <- 3*nv - np   if (!quiet) {     print(sprintf("   tmesh3d - nv:%d np:%d ni:%d maxi:%d mini:%d - vsaved:%d",nv,np,ni,max(vidx),min(vidx),nvsv))   }   part <- tmesh3d(vpnt,vidx,homogeneous = F)   #part <- translate3d(rotate3d(part,matrix = rot),trn[[1]],trn[[2]],trn[[3]])   # Center and orient the drone - determined these from the data   # Drone was upside down and facing the wrong way   # making the center to be the center of the pcb board   #   #pcbcen <- -0.5*c(54.09200, 71.18820, 75.60720)   #part <- translate3d(part,pcbcen[[1]],pcbcen[[2]],pcbcen[[3]])   #part <- rotate3d(part,pi,0,1,0) # rotate 180 around the y-axis   if (!quiet) {     calcMeshCog(part)   }   shade3d(part,color = amb,specular=spc,emissive=ems,alpha = alf,shiny = shiny)   comp$out_vp <- part$vb   comp$out_vi <- part$it   stats <- findBBox(comp$out_vp,compname)   comp$out_vp <- translatePointsFromMatrix(comp$out_vp, -stats$cenv )   comp$out_sca <- c(1,1,1)   # I don't know why this transformation of rot is necessary, but it is...   # m1 swaps Y&Z and then inverts all the axes   #   m1 <- matrix(c(-1,0,0,0,0,-1,0,-1,0),3,3)   comp$out_rot <- m1 %*% rot   #comp$out_rot <- matrix(c(1,0,0,0,1,0,0,0,1),3,3)   #comp$out_rot <- rot   comp$out_trn <- stats$cenv   stats <- findBBox(comp$out_vp,compname)   #comp$out_trn <- c(0,0,0)   return(comp) } addAxes <- function(len = 1) {   u <- c(0,1)*len   v <- c(0,0)   w <- c(0, 0)   lines3d(u, v, w, color = c("red"))   text3d(u,v,w,c("","X"),color=c("red"))   lines3d(w,u,v,color=c("green"))   text3d(w,u,v,c("","Y"),color=c("green"))   lines3d(v,w,u,color=c("blue"))   text3d(v,w,u,c("","Z"),color=c("blue")) } colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } plotWholeThing <- function(partAttList,partVertList,compList) {   for (cp in compList) {     compname <- cp$compname     partname <- gsub("\\-\\d$","",compname)     print(sprintf("Comp:%s part:%s",compname,partname))     rot <- cp$rot     trn <- cp$trn     prta <- partAttList[[partname]]     amb <- colVekToStringColor(prta$ambient)     dif <- colVekToStringColor(prta$diffuse)     spc <- colVekToStringColor(prta$specular)     ems <- colVekToStringColor(prta$emissive)     alf <- prta$ambient[4]     shn <- prta$shinyness     #print(prta$ambient)     vtl <- partVertList[[partname]]     newcp <- plotPartAsMesh(compname,partname,vtl,cp,trn,rot,amb,dif,spc,ems,alf,shn,hashemup = T)     newcp$partid <- prta$id     compList[[compname]] <- newcp   }   addAxes(len = 50)   axes3d()   return(compList) } readCompositionFromXml <- function(stldir,xfname) {   compList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   itree <- xml_find_first(doc, "//*[local-name()='InstanceTree']")   its <- xml_find_all(doc, "//*[local-name()='Instance']")   for (it in its) {     #print(as.character(it))     compname <- xml_attr(it, "name")     needpart <- gsub("\\-\\d$","",compname)     cp <- list()     cp$compname <- compname     cp$partname <- needpart     print(sprintf("Comp:%s need:%s",compname,needpart))     tform <- xml_find_first(it, ".//*[local-name()='Transform']")     if (length(tform) > 0) {       nrot <- xml_find_first(it, ".//*[local-name()='Rotation']")       rot <- matrix(as.numeric(str_split(xml_text(nrot), "\\s")[[1]]),3,3)       cp$rot <- round(rot,4)       ntrn <- xml_find_first(it,".//*[local-name()='Translation']")       # no idea where this factor of 1000 comes from (mm -> meters?)       # some STL brain damage no doubt       trn <- 1000.0*as.numeric(str_split(xml_text(ntrn),"\\s")[[1]])       cp$trn <- trn       cp$id <- 100*(length(compList)+1)       compList[[compname]] <- cp     }   }   return(compList) } readMaterialsFromXml <- function(stldir,xfname) {   partAttList <- list()   xmlfile <- sprintf("%s/%s",stldir,xfname)   doc <- read_xml(xmlfile)   its <- xml_find_all(doc,"//*[local-name()='Part']")   for (it in its) {     #print(as.character(it))     partname <- xml_attr(it,"name")     prt <- list()     prt$partname <- partname     if (!is.null(prt)) {       print(sprintf("Part:%s",partname))       nod <- xml_find_first(it,".//*[local-name()='Ambient']")       prt$ambient <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Diffuse']")       prt$diffuse <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Specular']")       prt$specular <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Emissive']")       prt$emissive <- as.numeric(c(xml_attr(nod,"r"),xml_attr(nod,"g"),xml_attr(nod,"b"),xml_attr(nod,"a")))       nod <- xml_find_first(it,".//*[local-name()='Shininess']")       prt$shinyness <- as.numeric(xml_text(nod))       print(sprintf("   amb - %.3f",prt$ambient))       print(sprintf("   dif - %.3f",prt$diffuse))       print(sprintf("   spc - %.3f",prt$specular))       print(sprintf("   emi - %.3f",prt$emissive))       print(sprintf("   shn - %.3f",prt$shinyness))       prt$id <- 100*(length(partAttList)+1)       partAttList[[partname]] <- prt     }   }   return(partAttList) } fixupname <- function(oname) {   name <- oname   name <- gsub("motor mount-1","motor mount-1",name)   name <- gsub("motor mount-3","motor mount-2",name)   name <- gsub("motor mount-4","motor mount-3",name)   name <- gsub("motor mount-5","motor mount-4",name)   name <- gsub("motor-1","motor---2",name)   name <- gsub("motor-3","motor---1",name)   name <- gsub("motor-2","motor---4",name)   name <- gsub("motor-4","motor---3",name)   name <- gsub("---","-",name)   return(name) } writeOutCzfFiles <- function(fnameroot = "crazyflie",partAttList,partVertList,compList) {   # Components   cdf <- NULL   for (c in compList) {     vs <- round(c$out_sca,5)     vt <- round(c$out_trn,5)     mr <- round(c$out_rot,5)     if (c$id == 1500) {       # pcb not behaving like the rest. No idea why.       mr <- matrix(c(1,0,0,0,1,0,0,0,1),3,3)     }     if (str_detect(c$compname,"propeller")) {        layers <- "cf//base"     } else {       layers <- "cf//staticprop"     }     options=""     fixcompname <- fixupname(c$compname)     c1df <- data.frame(id = c$id,compname = fixcompname,                        partid = c$partid,partname = c$partname,                        layers=layers,                        options=options,                        sca.x = vs[1],sca.y = vs[2],sca.z = vs[3],                        trn.x = vt[1],trn.y = vt[2],trn.z = vt[3],                        rot.11 = mr[1,1],rot.12 = mr[1,2],rot.13 = mr[1,3],                        rot.21 = mr[2,1],rot.22 = mr[2,2],rot.23 = mr[2,3],                        rot.31 = mr[3,1],rot.32 = mr[3,2],rot.33 = mr[3,3]                        )     cdf <- rbind(cdf,c1df)   }   cdf <- cdf[order(as.character(cdf$compname)),]   fname <- sprintf("%s-components.csv",fnameroot)   write.csv(cdf,fname,row.names = F)   # Parts   pdf <- NULL   for (p in partAttList) {     p1df <- data.frame(partid = p$id,partname=p$partname,       amb.r = p$ambient[[1]],amb.g = p$ambient[[2]],amb.b = p$ambient[[3]],amb.a = p$ambient[[4]],       dif.r = p$diffuse[[1]],dif.g = p$diffuse[[2]],dif.b = p$diffuse[[3]],dif.a = p$diffuse[[4]],       spc.r = p$specular[[1]],spc.g = p$specular[[2]],spc.b = p$specular[[3]],spc.a = p$specular[[4]],       ems.r = p$emissive[[1]],ems.g = p$emissive[[2]],ems.b = p$emissive[[3]],ems.a = p$emissive[[4]],       shinyness=p$shinyness       )     pdf <- rbind(pdf,p1df)   }   fname <- sprintf("%s-parts.csv",fnameroot)   write.csv(pdf,fname,row.names = F)   # Points   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(round(c$out_vp,5)))     names(pt1df) <- c("x","y","z","w")     pt1df$partid <- c$partid     # only interested in writing the first component for every part     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {        ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-points.csv",fnameroot)   write.csv(ptdf,fname,row.names = F)   # VertsIdx   ptdf <- NULL   for (c in compList) {     pt1df <- as.data.frame(t(c$out_vi))     names(pt1df) <- c("v1","v2","v3")     #pt1df$id <- c$id     pt1df$partid <- c$partid     # only write out the first ones     fcidx <- which(cdf$partname == c$partname)[[1]]     fcid <- cdf$id[fcidx]     if (fcid == c$id) {       ptdf <- rbind(ptdf,pt1df)     }   }   fname <- sprintf("%s-vertidx.csv",fnameroot)   write.csv(ptdf,fname,row.names = F) } # Start of actual program # ======================= starttime <- Sys.time() stldir <- "../Crazyflie-CAD/STL" # Get the STL files with the vertices and read them in stlfiles <- list.files(stldir,"\\.STL$") partVertList <- list() for (fname in stlfiles) {   partVertList <- readCzfVertsFromStl(stldir,fname,partVertList) } # Now read the composistion file which has the part instances,  #  their transformations which position them, and their material properties #  compList <- readCompositionFromXml(stldir,"Crazyflie_assembly.xml") compList <- compList[order(sapply(compList,'[[',"compname"))]  # order them partAttList <- readMaterialsFromXml(stldir,"Crazyflie_assembly.xml") partAttList <- partAttList[order(sapply(partAttList,'[[',"partname"))] # order them compList <- plotWholeThing(partAttList,partVertList,compList) writeOutCzfFiles("crazyflie",partAttList,partVertList,compList) elap <- as.numeric((Sys.time() - starttime)[1], units = "secs") print(sprintf("Run took %.1f secs for %d verts - verts optimized away:%d", elap,nvtot,nvsaved))
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   cdf$rot <- lapply(1:nc,function(i) matrix(c( cdf$rot.11[i],cdf$rot.12[i],cdf$rot.13[i],                                                cdf$rot.21[i],cdf$rot.22[i],cdf$rot.23[i],                                                cdf$rot.31[i],cdf$rot.32[i],cdf$rot.33[i]),3,3))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } plotMesh <- function(obj) {   cdf <- obj$cdf   pdf <- obj$pdf   ptdf <- obj$ptdf   vidf <- obj$vidf   ncomp <- nrow(obj$cdf)   npart <- nrow(obj$pdf)   for (cidx in 1:ncomp) {     # setup     cid <- cdf$id[cidx]     cname <- cdf$compname[cidx]     pname <- cdf$partname[cidx]     pidx <- which(pdf$partname == pname)     partid <- pdf$partid[pidx]     # get the points for this component     pt1df <- ptdf[ptdf$partid == partid,]     pt1df$partid <- NULL     mpt <- t(as.matrix(pt1df))     # get the indexs for this component     vi1df <- vidf[vidf$partid == partid,]     vi1df$partid <- NULL     mvi <- t(as.matrix(vi1df))     # make the mesh, then rotate and transform if necssary     mesh <- tmesh3d(mpt,mvi)     sca <- cdf$sca[[cidx]]     rot <- cdf$rot[[cidx]]     trn <- cdf$trn[[cidx]]     mesh <- scale3d(mesh,x = sca[1],y = sca[2],z = sca[3])     mesh <- rotate3d(mesh,matrix = rot)     mesh <- translate3d(mesh,trn[1],trn[2],trn[3])     # render it     print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))     clr <- pdf$amb[pidx]     # mounts and motor part id numbers      #   1 1600 500     #   2 1100 300     #   3 100 600     #   4 200 400     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } open3d() robv <- readMesh("crazyflie") plotMesh(robv) addAxes(50)
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   cdf$rot <- lapply(1:nc,function(i) matrix(c( cdf$rot.11[i],cdf$rot.12[i],cdf$rot.13[i],                                                cdf$rot.21[i],cdf$rot.22[i],cdf$rot.23[i],                                                cdf$rot.31[i],cdf$rot.32[i],cdf$rot.33[i]),3,3))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } plotMesh <- function(obj) {   cdf <- obj$cdf   pdf <- obj$pdf   ptdf <- obj$ptdf   vidf <- obj$vidf   ncomp <- nrow(obj$cdf)   npart <- nrow(obj$pdf)   for (cidx in 1:ncomp) {     # setup     cid <- cdf$id[cidx]     cname <- cdf$compname[cidx]     pname <- cdf$partname[cidx]     pidx <- which(pdf$partname == pname)     partid <- pdf$partid[pidx]     # get the points for this component     pt1df <- ptdf[ptdf$partid == partid,]     pt1df$partid <- NULL     mpt <- t(as.matrix(pt1df))     # get the indexs for this component     vi1df <- vidf[vidf$partid == partid,]     vi1df$partid <- NULL     mvi <- t(as.matrix(vi1df))     # make the mesh, then rotate and transform if necssary     mesh <- tmesh3d(mpt,mvi)     sca <- cdf$sca[[cidx]]     rot <- cdf$rot[[cidx]]     trn <- cdf$trn[[cidx]]     mesh <- scale3d(mesh,x = sca[1],y = sca[2],z = sca[3])     mesh <- rotate3d(mesh,matrix = rot)     mesh <- translate3d(mesh,trn[1],trn[2],trn[3])     # render it     print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))     clr <- pdf$amb[pidx]     # mounts and motor part id numbers      #   1 1600 500     #   2 1100 300     #   3 100 600     #   4 200 400     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } open3d() robv <- readMesh("crazyflie") plotMesh(robv) addAxes(50)
rtvs::debug_source("rgl4crazyflie.R")
library(rgl) library(stringr) library(xml2) library(hash) # #  Mike Wise - Nov/Dec 2016 # #  Program in R to read in and plot CAD model of CrazyFlie mini-drone # # colVekToStringColor <- function(clr) {   clr <- pmax(0,pmin(clr,1))   iclr <- round(255 * clr)   hclr <- sprintf("#%2.2x%2.2x%2.2x",iclr[[1]],iclr[[2]],iclr[[3]])   return(hclr) } rgbToStringColor <- function(rvek,gvek,bvek) {   nr <- length(rvek)   m <- matrix(c(rvek,gvek,bvek),nr,3) # matrix with row as r,g,b   l <- lapply(1:dim(m)[1],function(x) m[x,]) # now unwrap into a list of rgb's   rgb <- sapply(l,colVekToStringColor) } readMesh <- function(fnameroot = "crazyflie") {   # Components   fname <- sprintf("%s-components.csv",fnameroot)   cdf <- read.csv(fname)   cdf <- cdf[cdf$id > 0,]   nc <- nrow(cdf)   cdf$sca <- lapply(1:nc,function(i) c(cdf$sca.x[i],cdf$sca.y[i],cdf$sca.z[i]))   cdf$trn <- lapply(1:nc,function(i) c(cdf$trn.x[i],cdf$trn.y[i],cdf$trn.z[i]))   cdf$rot <- lapply(1:nc,function(i) matrix(c( cdf$rot.11[i],cdf$rot.12[i],cdf$rot.13[i],                                                cdf$rot.21[i],cdf$rot.22[i],cdf$rot.23[i],                                                cdf$rot.31[i],cdf$rot.32[i],cdf$rot.33[i]),3,3))   # Parts   fname <- sprintf("%s-parts.csv",fnameroot)   pdf <- read.csv(fname)   pdf$amb <- rgbToStringColor(pdf$amb.r,pdf$amb.g,pdf$amb.b)   pdf$dif <- rgbToStringColor(pdf$dif.r,pdf$dif.g,pdf$dif.b)   pdf$spc <- rgbToStringColor(pdf$spc.r,pdf$spc.g,pdf$spc.b)   pdf$ems <- rgbToStringColor(pdf$ems.r,pdf$ems.g,pdf$ems.b)   # Points   fname <- sprintf("%s-points.csv",fnameroot)   ptdf <- read.csv(fname)   # VertsIdx   fname <- sprintf("%s-vertidx.csv",fnameroot)   vidf <- read.csv(fname)   rv <- list()   rv$cdf <- cdf   rv$pdf <- pdf   rv$ptdf <- ptdf   rv$vidf <- vidf   return(rv) } addAxes <- function(len = 1,t = c(0,0,0),r = NULL,tit = "") {   u <- c(0,1) * len   v <- c(0,0)   w <- c(0,0)   lines3d(u + t[1],v + t[2],w + t[3],color = c("red"))   text3d(u + t[1],v + t[2],w + t[3],c("","X"),color = c("red"),cex = 1)   lines3d(w + t[1],u + t[2],v + t[3],color = c("green"))   text3d(w + t[1],u + t[2],v + t[3],c("","Y"),color = c("green"))   lines3d(v + t[1],w + t[2],u + t[3],color = c("blue"))   text3d(v + t[1],w + t[2],u + t[3],c("","Z"),color = c("blue")) } plotMesh <- function(obj) {   cdf <- obj$cdf   pdf <- obj$pdf   ptdf <- obj$ptdf   vidf <- obj$vidf   ncomp <- nrow(obj$cdf)   npart <- nrow(obj$pdf)   for (cidx in 1:ncomp) {     # setup     cid <- cdf$id[cidx]     cname <- cdf$compname[cidx]     pname <- cdf$partname[cidx]     pidx <- which(pdf$partname == pname)     partid <- pdf$partid[pidx]     # get the points for this component     pt1df <- ptdf[ptdf$partid == partid,]     pt1df$partid <- NULL     mpt <- t(as.matrix(pt1df))     # get the indexs for this component     vi1df <- vidf[vidf$partid == partid,]     vi1df$partid <- NULL     mvi <- t(as.matrix(vi1df))     # make the mesh, then rotate and transform if necssary     mesh <- tmesh3d(mpt,mvi)     sca <- cdf$sca[[cidx]]     rot <- cdf$rot[[cidx]]     trn <- cdf$trn[[cidx]]     mesh <- scale3d(mesh,x = sca[1],y = sca[2],z = sca[3])     mesh <- rotate3d(mesh,matrix = rot)     mesh <- translate3d(mesh,trn[1],trn[2],trn[3])     # render it     print(sprintf("%25s cid:%4d  - cidx:%2d pidx:%2d pts:%5d vidx:%5d",                cname,cid,cidx,pidx,length(mpt),length(mvi)))     clr <- pdf$amb[pidx]     # mounts and motor part id numbers      #   1 1600 500     #   2 1100 300     #   3 100 600     #   4 200 400     shade3d(mesh,color = clr,alpha = pdf$amb.a[pidx])     addAxes(10,t = trn,r = rot) # show the local coordinate system   } } open3d() robv <- readMesh("crazyflie") plotMesh(robv) addAxes(50)
